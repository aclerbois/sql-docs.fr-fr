---
title: Guide de référence des opérateurs Showplan logiques et physiques
ms.custom: ''
ms.date: 10/12/2017
ms.prod: sql
ms.prod_service: database-engine, sql-database
ms.component: relational-databases-misc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- database-engine
ms.tgt_pltfrm: ''
ms.topic: conceptual
f1_keywords:
- sql13.swb.showplan.leftouterjoin.f1
- sql13.swb.showplan.remotedelete.f1
- sql13.swb.showplan.parallelism.f1
- sql13.swb.showplan.indexspool.f1
- sql13.swb.showplan.result.f1
- sql13.swb.showplan.bitmapcreate.f1
- sql13.swb.showplan.remotescan.f1
- sql13.swb.showplan.union.f1
- sql13.swb.showplan.bitmap.f1
- sql13.swb.showplan.RIDLookup
- sql13.swb.showplan.innerjoin.f1
- sql13.swb.showplan.dynamic.f1
- sql13.swb.showplan.distributestreams.f1
- sql13.swb.showplan.clusteredindexdelete.f1
- sql13.swb.showplan.keylookup.f1
- sql13.swb.showplan.partialaggregate.f1
- sql13.swb.showplan.distinctsort.f1
- sql13.swb.showplan.collapse.f1
- sql13.swb.showplan.print.f1
- sql13.swb.showplan.crossjoin.f1
- sql13.swb.showplan.convert.f1
- sql13.swb.showplan.split.f1
- sql13.swb.showplan.top.f1
- sql13.swb.showplan.update.f1
- sql13.swb.showplan.keyset.f1
- sql13.swb.showplan.fetchquery.f1
- sql13.swb.showplan.mergejoin.f1
- sql13.swb.showplan.branchrepartition.f1
- sql13.swb.showplan.tableinsert.f1
- sql13.swb.showplan.clusteredindexseek.f1
- sql13.swb.showplan.indexupdate.f1
- sql13.swb.showplan.indexinsert.f1
- sql13.swb.showplan.clusteredindexupdate.f1
- sql13.swb.showplan.streamaggregate.f1
- sql13.swb.showplan.columnstoreindexdelete.f1
- sql13.swb.showplan.snapshot.f1
- sql13.swb.showplan.remotequery.f1
- sql13.swb.showplan.constantscan.f1
- sql13.swb.showplan.rank.f1
- sql13.swb.showplan.rightsemijoin.f1
- sql13.swb.showplan.delete.f1
- sql13.swb.showplan.sequence.f1
- sql13.swb.showplan.locate.f1
- sql13.swb.showplan.aggregate.f1
- sql13.swb.showplan.rightouterjoin.f1
- sql13.swb.showplan.columnstoreindexupdate.f1
- sql13.swb.showplan.clusteredindexinsert.f1
- sql13.swb.showplan.rowcountspool.f1
- sql13.swb.showplan.columnstoreindexscan.f1
- sql13.swb.showplan.leftantisemijoin.f1
- sql13.swb.showplan.sort.f1
- sql13.swb.showplan.leftsemijoin.f1
- sql13.swb.showplan.columnstoreindexinsert.f1
- sql13.swb.showplan.indexscan.f1
- sql13.swb.showplan.columnstoreindexmerge.f1
- sql13.swb.showplan.lazyspool.f1
- sql13.swb.showplan.rightantisemijoin.f1
- sql13.swb.showplan.bookmarklookup.f1
- sql13.swb.showplan.remoteinsert.f1
- sql13.swb.showplan.intrinsic.f1
- sql13.swb.showplan.arithmeticexpression.f1
- sql13.swb.showplan.populationquery.f1
- sql13.swb.showplan.filter.f1
- sql13.swb.showplan.if.f1
- sql13.swb.showplan.hashmatchteam.f1
- sql13.swb.showplan.tablevaluedfunction.f1
- sql13.swb.showplan.assign.f1
- sql13.swb.showplan.nestedloops.f1
- sql13.swb.showplan.buildhash.f1
- sql13.swb.showplan.mergeinterval.f1
- sql13.swb.showplan.hashmatch.f1
- sql13.swb.showplan.parametertablescan.f1
- sql13.swb.showplan.tablemerge.f1
- sql13.swb.showplan.switch.f1
- sql13.swb.showplan.sql.f1
- sql13.swb.showplan.repartitionstreams.f1
- sql13.swb.showplan.logrowscan.f1
- sql13.swb.showplan.assert.f1
- sql13.swb.showplan.computescalar.f1
- sql13.swb.showplan.broadcast.f1
- sql13.swb.showplan.indexseek.f1
- sql13.swb.showplan.gatherstreams.f1
- sql13.swb.showplan.remoteindexscan.f1
- sql13.swb.showplan.segment.f1
- sql13.swb.showplan.tableupdate.f1
- sql13.swb.showplan.clusteredindexscan.f1
- sql13.swb.showplan.cache.f1
- sql13.swb.showplan.spool.f1
- sql13.swb.showplan.indexdelete.f1
- sql13.swb.showplan.distinct.f1
- sql13.swb.showplan.deletedscan.f1
- sql13.swb.showplan.eagerspool.f1
- sql13.swb.showplan.hashmatchroot.f1
- sql13.swb.showplan.setfunction.f1
- sql13.swb.showplan.clusteredindexmerge.f1
- sql13.swb.showplan.flowdistinct.f1
- sql13.swb.showplan.tabledelete.f1
- sql13.swb.showplan.tablescan.f1
- sql13.swb.showplan.refreshquery.f1
- sql13.swb.showplan.tablespool.f1
- sql13.swb.showplan.insertedscan.f1
- sql13.swb.showplan.insert.f1
- sql13.swb.showplan.remoteindexseek.f1
- sql13.swb.showplan.fullouterjoin.f1
- sql13.swb.showplan.declare.f1
- sql13.swb.showplan.udx.f1
- sql13.swb.showplan.while.f1
- sql13.swb.showplan.remoteupdate.f1
- sql13.swb.showplan.concatenation.f1
- sql13.swb.showplan.computescalar
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
caps.latest.revision: 51
author: rothja
ms.author: jroth
manager: craigg
monikerRange: = azuresqldb-current || >= sql-server-2016 || = sqlallproducts-allversions
ms.openlocfilehash: 75aeadbf83ba580545ed97e9c7d5f13ea24ecda5
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: HT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/03/2018
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Guide de référence des opérateurs Showplan logiques et physiques
[!INCLUDE[appliesto-ss-asdb-xxxx-xxx-md](../includes/appliesto-ss-asdb-xxxx-xxx-md.md)]
  Les opérateurs décrivent comment [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] exécute une requête ou une instruction DML (Data Manipulation Language). L'optimiseur de requête utilise des opérateurs pour construire un plan de requête qui crée le résultat spécifié dans la requête ou pour exécuter l'opération spécifiée dans l'instruction DML. Le plan de requête est une arborescence composée d'opérateurs physiques. Vous pouvez afficher le plan de requête à l'aide des instructions SET SHOWPLAN, des options plan d'exécution graphique dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]ou des classes d'événements Showplan de SQL Server Profiler.  
  
 Les opérateurs sont classés en opérateurs logiques et physiques.  
  
 **Opérateurs logiques**  
 Les opérateurs logiques décrivent l'opération algébrique relationnelle utilisée pour traiter une instruction. En d'autres termes, les opérateurs logiques décrivent de manière conceptuelle les opérations à exécuter.  
  
 **Opérateurs physiques**  
 Les opérateurs physiques mettent en œuvre l'opération décrite par des opérateurs logiques. Chaque opérateur physique désigne un objet ou une routine chargée d'effectuer une opération. Par exemple, certains opérateurs physiques permettent d'accéder à des colonnes ou des lignes à partir d'une table, d'un index ou d'une vue. D'autres opérateurs physiques exécutent d'autres opérations telles que des calculs, des agrégations, des contrôles de l'intégrité des données vérifie ou des jointures. Des coûts sont associés aux opérateurs physiques.  
  
 Les opérateurs physiques s'initialisent, collectent des données et se ferment. En particulier, l'opérateur physique peut répondre aux trois méthodes d'appel suivantes :  
  
-   **Init()**: avec la méthode **Init()** , l’opérateur physique s’initialise et configure les structures de données nécessaires. Il arrive que l’opérateur physique reçoive beaucoup d’appels **Init()** , bien qu’en général il n’en reçoive qu’un.  
  
-   **GetNext()**: avec la méthode **GetNext()** , l’opérateur physique récupère la première ligne de données ou la suivante. L’opérateur physique peut recevoir zéro ou de nombreux appels **GetNext()** .  
  
-   **Close()**: avec la méthode **Close()** , l’opérateur physique effectue certaines opérations de nettoyage et se ferme. Un opérateur physique reçoit un seul appel **Close()** .  
  
 La méthode **GetNext()** renvoie une ligne de données, et le nombre d’appels qu’elle reçoit s’affiche sous **ActualRows** dans le résultat Showplan produit au moyen de SET STATISTICS PROFILE ON ou SET STATISTICS XML ON. Pour plus d’informations sur ces options SET, consultez [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-profile-transact-sql.md) et [SET STATISTICS XML &#40;Transact-SQL&#41;](../t-sql/statements/set-statistics-xml-transact-sql.md).  
  
 Les compteurs **ActualRebinds** et **ActualRewinds** qui s’affichent dans le résultat de Showplan indiquent le nombre de fois que la méthode **Init()** est appelée. Sauf si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, **ActualRebinds** est égal à un et **ActualRewinds** est égal à zéro. Si un opérateur se trouve sur le côté intérieur d'une jointure de boucles, le nombre total de reliaisons et de rembobinages doit être égal au nombre de ligne traitées sur le côté extérieur de la jointure. Une reliaison signifie qu'un ou plusieurs des paramètres corrélés de la jointure ont changé, et que le côté intérieur doit être réévalué. Un rembobinage signifie qu'aucun des paramètres corrélés n'a changé, et que l'ancien jeu de résultats interne peut être réutilisé.  
  
 **ActualRebinds** et **ActualRewinds** sont présents dans le résultat de Showplan XML produit en utilisant SET STATISTICS XML ON. Ils ne sont remplis que pour les opérateurs **Nonclustered Index Spool**, **Remote Query**, **Row Count Spool**, **Sort**, **Table Spool**et **Table-valued Function** . **ActualRebinds** et **ActualRewinds** peuvent aussi être remplis pour les opérateurs **Assert** et **Filter** lorsque l'attribut **StartupExpression** est défini à TRUE.  
  
 Lorsque **ActualRebinds** et **ActualRewinds** sont présents dans un Showplan XML, ils sont comparables à **EstimateRebinds** et **EstimateRewinds**. S’ils sont absents, le nombre estimé de lignes (**EstimateRows**) est comparable au nombre réel de lignes (**ActualRows**). Sachez que le résultat du Showplan graphique réel affiche des zéros pour les reliaisons réelles et les rembobinages réels lorsqu'ils sont absents.  
  
 Un compteur apparenté, **ActualEndOfScans**, est disponible uniquement si le résultat de Showplan est produit au moyen de SET STATISTICS XML ON. Chaque fois qu'un opérateur physique atteint la fin de son flux de données, le compteur est incrémenté de un. Un opérateur physique peut atteindre la fin de son flux de données zéro, une ou de nombreuses fois. Comme pour les reliaisons et les rembobinages, le nombre de fins d'analyses ne peut être supérieur à un que si l'opérateur se situe sur le côté intérieur d'une jointure de boucles. Le nombre de fins d'analyses doit être inférieur ou égal au nombre total des reliaisons et des rembobinages.  
  
## <a name="mapping-physical-and-logical-operators"></a>Mappage d'opérateurs physiques et logiques  
 L'optimiseur de requête crée un plan de requête sous forme d'arborescence d'opérateurs logiques. Après avoir créé le plan, l'optimiseur de requête choisit l'opérateur physique le plus efficace pour chaque opérateur logique. L'optimiseur de requête utilise une approche basée sur les coûts pour déterminer l'opérateur physique qui mettra en œuvre un opérateur logique.  
  
 Généralement, une opération logique peut être mise en œuvre par plusieurs opérateurs physiques. Toutefois, en de rares occasions, un opérateur physique peut également mettre en œuvre plusieurs opérations logiques.  
  
## <a name="operator-descriptions"></a>Description des opérateurs  
 Cette section contient la description des opérateurs logiques et physiques.  
  
|Icône du plan d'exécution graphique|Opérateur Showplan|Description|  
|-----------------------------------|-----------------------|-----------------|  
|![Icône d’opérateur de jointure adaptative](../relational-databases/media/AdaptiveJoin.gif "Icône d’opérateur de jointure adaptative")|**Jointure adaptative**|L’opérateur de **jointure adaptative** permet de choisir de différer une jointure hachée ou une méthode de jointure de boucles imbriquées tant que la première entrée n’a pas été analysée. | 
|None|**Agrégat**|L'opérateur **Aggregate** calcule une expression contenant MIN, MAX, SUM, COUNT ou AVG. L'opérateur **Aggregate** peut être un opérateur logique ou physique.|  
|![Icône d’opérateur Arithmetic Expression](../relational-databases/media/arithmetic-expression-32x-2.gif "Icône d’opérateur Arithmetic Expression")|**Arithmetic Expression**|L'opérateur **Arithmetic Expression** calcule une nouvelle valeur à partir de valeurs existantes dans une ligne. L’opérateur**Arithmetic Expression** n’est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur Assert](../relational-databases/media/assert-32x.gif "Icône d’opérateur Assert")|**Assert**|L'opérateur **Assert** vérifie une condition. Par exemple, il valide l'intégrité référentielle ou garantit qu'une sous-requête scalaire retourne une ligne. Pour chaque ligne d'entrée, l'opérateur **Assert** résout l'expression de la colonne **Argument** du plan d'exécution. Si cette expression a pour résultat NULL, l'opérateur **Assert** passe la ligne et la requête d'exécution se poursuit. Si cette expression a pour résultat une valeur non NULL, l'erreur correspondante est levée. L'opérateur **Assert** est un opérateur physique.|  
|![Icône de l’élément de langage Assign](../relational-databases/media/assign-32.gif "Icône de l’élément de langage Assign")|**Assign**|L'opérateur **Assign** assigne la valeur d'une expression ou une constante à une variable. **Assign** est un élément de langage.|  
|None|**Async Concat**|L’opérateur **Async Concat** est utilisé seulement dans les requêtes distantes (requêtes distribuées). Elle a *n* enfants et un nœud parent. En règle générale, certains des enfants sont des ordinateurs distants qui participent à une requête distribuée. **Async Concat** émet des appels `open()` à tous les enfants simultanément et applique ensuite une bitmap à chacun d’eux. Pour chaque bit à 1, **Async Concat** envoie à la demande les lignes obtenues au nœud parent.|  
|![Icône d’opérateur Bitmap](../relational-databases/media/bitmap-32x.gif "Icône d’opérateur Bitmap")|**Bitmap**|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] utilise l’opérateur **Bitmap** pour implémenter le filtrage Bitmap dans les plans de requête parallèles. Le filtrage Bitmap accélère l'exécution des requêtes en éliminant les lignes contenant des valeurs de clés qui ne peuvent pas produire d'enregistrements de jointure avant de transmettre les lignes à un autre opérateur tel que l'opérateur **Parallelism** . Un filtre Bitmap utilise une représentation compacte d'un ensemble de valeurs d'une table dans une partie de l'arborescence de l'opérateur pour filtrer les lignes d'une seconde table dans une autre partie de l'arborescence. Avec la suppression des lignes inutiles tôt dans la requête, les opérateurs suivants ont moins de lignes à traiter et les performances globales de la requête sont améliorées. L'optimiseur détermine quand un filtre Bitmap est suffisamment sélectif pour être utile et dans quels opérateurs le filtre doit être appliqué. **Bitmap** est un opérateur physique.|  
|![Icône d’opérateur Bitmap](../relational-databases/media/bitmap-32x.gif "Icône d’opérateur Bitmap")|**Bitmap Create**|L'opérateur **Bitmap Create** apparaît dans la sortie de plan d'exécution de requêtes où les bitmaps sont construites. **Bitmap Create** est un opérateur logique.|  
|![Icône d’opérateur Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|**Bookmark Lookup**|L’opérateur **Bookmark Lookup** utilise un signet (ID de ligne ou clé de clustering) pour rechercher la ligne correspondante dans la table ou l’index cluster. La colonne **Argument** contient l'étiquette de signet utilisée pour rechercher la ligne dans la table ou l'index cluster. La colonne **Argument** contient également le nom de la table ou de l’index cluster où s’effectue la recherche de la ligne. Si la clause WITH PREFETCH apparaît dans la colonne **Argument** , cela signifie que le processeur de requêtes a décidé que la prérécupération asynchrone (lecture anticipée) constitue la solution optimale pour la recherche de signets dans la table ou dans l’index cluster.<br /><br /> **Bookmark Lookup** n'est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)]. À la place, **Clustered Index Seek** et **RID Lookup** fournissent des fonctionnalités de recherche de signet. L'opérateur **Key Lookup** fournit également ces fonctionnalités.|  
|None|**Branch Repartition**|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs **Parallelism** d'une région distincte sont appelés **Branch Repartition**. L'itérateur **Parallelism** situé à la limite de deux régions de ce type est appelé **Segment Repartition**. **Branch Repartition** et **Segment Repartition** sont des opérateurs logiques.|  
|None|**Broadcast**|**Broadcast** comporte un nœud enfant et *n* nœuds parents. **Broadcast** envoie ses lignes d'entrée à plusieurs consommateurs à la demande. Chaque consommateur obtient toutes les lignes. Par exemple, si tous les consommateurs se trouvent des côtés construction d'une jointure de hachage, *n* copies des tables de hachage sont générées.|  
|![Icône d’opérateur Build Hash](../relational-databases/media/build-hash.gif "Icône d’opérateur Build Hash")|**Build Hash**|Indique la création d'une table de hachage de lot pour un index columnstore optimisé en mémoire xVelocity.|  
|None|**Cache**|**Cache** est une version spéciale de l'opérateur **Spool** . Il ne stocke qu'une seule ligne de données. **Cache** est un opérateur logique. **Cache** n'est pas utilisé dans [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].|  
|![Icône d’opérateur Clustered Index Delete](../relational-databases/media/clustered-index-delete-32x.gif "Icône d’opérateur Clustered Index Delete")|**Clustered Index Delete**|L’opérateur **Clustered Index Delete** supprime des lignes de l’index cluster spécifié dans la colonne Argument du plan d’exécution de requête. Si un prédicat WHERE:() figure dans la colonne Argument, seules les lignes répondant au prédicat sont supprimées.**Clustered Index Delete** est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Insert](../relational-databases/media/clustered-index-insert-32x.gif "Icône d’opérateur Clustered Index Insert")|**Clustered Index Insert**|L’opérateur **Clustered Index Insert** Showplan insère des lignes de son entrée dans l’index cluster spécifié dans la colonne Argument. Cette colonne contient également un prédicat SET:(), qui indique la valeur à laquelle chaque colonne est définie. Si **Clustered Index Insert** ne possède pas d'enfant pour les valeurs insert, la ligne insérée est extraite de l'opérateur **Insert** lui-même.**Clustered Index Insert** est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Merge](../relational-databases/media/clustered-index-merge-32x.gif "Icône d’opérateur Clustered Index Merge")|**Clustered Index Merge**|L'opérateur **Clustered Index Merge** applique un flux de données de fusion à un index cluster. L'opérateur supprime, met à jour ou insère des lignes de l'index cluster spécifié dans la colonne **Argument** de l'opérateur. L'opération réellement effectuée dépend de la valeur d'exécution de la colonne **ACTION** spécifiée dans la colonne **Argument** de l'opérateur. **Clustered Index Merge** est un opérateur physique.|  
|![Icône d’opérateur Clustered Index Scan](../relational-databases/media/clustered-index-scan-32x.gif "Icône d’opérateur Clustered Index Scan")|**Clustered Index Scan**|L’opérateur **Clustered Index Scan** analyse l’index cluster spécifié dans la colonne Argument du plan d’exécution de requête. Lorsqu'un prédicat facultatif WHERE:() y figure, seules les lignes répondant au prédicat sont retournées. Si la colonne Argument contient la clause ORDERED, cela signifie que le processeur de requêtes a demandé le renvoi des sorties de lignes dans l'ordre dans lequel l'index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. **Clustered Index Scan** est un opérateur logique et physique.|  
|![Icône d’opérateur Clustered Index Seek](../relational-databases/media/clustered-index-seek-32x.gif "Icône d’opérateur Clustered Index Seek")|**Clustered Index Seek**|L'opérateur **Clustered Index Seek** utilise la fonction recherche des index pour extraire des lignes d'un index cluster. La colonne **Argument** contient le nom de l’index cluster utilisé et le prédicat SEEK:(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant à ce prédicat SEEK:(). Il peut également inclure un prédicat WHERE: () dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:(), mais ceci est facultatif et ne fait pas appel aux index pour exécuter ce processus.<br /><br /> Si la colonne **Argument** contient la clause ORDERED, le processeur de requêtes a déterminé que les lignes doivent être retournées dans l'ordre dans lequel l'index cluster les a triées. Si la clause ORDERED n'y figure pas, le moteur de stockage effectue la recherche dans l'index de façon optimale, sans nécessairement trier la sortie. Autoriser la sortie à conserver son classement peut s'avérer moins efficace que la production d'une sortie non triée. Lorsque le mot clé LOOKUP apparaît, une recherche de signet est alors exécutée. Dans [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] et les versions ultérieures, l'opérateur **Key Lookup** fournit la fonctionnalité de recherche de signet. **Clustered Index Seek** est un opérateur logique et physique.|  
|![Icône d’opérateur Clustered Index Update](../relational-databases/media/clustered-index-update-32x.gif "Icône d’opérateur Clustered Index Update")|**Clustered Index Update**|L’opérateur **Clustered Index Update** met à jour les lignes d’entrée dans l’index cluster spécifié dans la colonne **Argument** . Si un prédicat WHERE:() est présent, seules les lignes répondant à ce prédicat sont mises à jour. Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. Si un prédicat DEFINE:() est présent, il établit la liste des valeurs définies par cet opérateur. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur, et ailleurs dans cette requête. **Clustered Index Update** est un opérateur logique et physique.|  
|![Icône d’opérateur Collapse](../relational-databases/media/collapse-32x.gif "Icône d’opérateur Collapse")|**Collapse**|L'opérateur **Collapse** permet d'optimiser le traitement de mise à jour des données. Lorsqu’une mise à jour est effectuée, elle peut être divisée (par l’opérateur **Split** ) en opérations de suppression puis d’insertion de données. La colonne **Argument** contient une clause GROUP BY:() qui spécifie la liste des colonnes clés. Si le processeur de requêtes rencontre des lignes adjacentes d'instructions de suppression puis d'insertion des mêmes valeurs de clé, il regroupe alors ces opérations en une seule et même opération de mise à jour pour gagner en efficacité. **Collapse** est un opérateur logique et physique.|  
|![Analyse d'index columnstore](../relational-databases/media/columnstoreindexscan.gif "Analyse d'index columnstore")|**Analyse d'index columnstore**|L'opérateur **Columnstore Index Scan** analyse l'index columnstore spécifié dans la colonne **Argument** du plan d'exécution de requête.|  
|![Icône d’opérateur Compute Scalar](../relational-databases/media/compute-scalar-32x.gif "Icône d’opérateur Compute Scalar")|**Compute Scalar**|L'opérateur **Compute Scalar** évalue une expression pour produire une valeur scalaire calculée. Celle-ci peut ensuite être retournée à l'utilisateur, référencée n'importe où dans la requête, ou les deux. Les deux sont utilisés par exemple dans un prédicat de filtre ou de jointure. **Compute Scalar** est un opérateur logique et physique.<br /><br /> Il se peut que les opérateurs**Compute Scalar** qui apparaissent dans les plans d'exécution générés par SET STATISTICS XML ne contiennent pas l'élément **RunTimeInformation** . Dans les plans d'exécution graphiques, **Actual Rows**, **Actual Rebinds**et **Actual Rewinds** peuvent être absents de la fenêtre **Propriétés** lorsque l'option **Inclure le plan d'exécution réel** est sélectionnée dans [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]. Si cela se produit, cela signifie que, même si ces opérateurs ont été utilisés dans le plan de requête compilé, leur travail a été exécuté par d'autres opérateurs dans le plan de requête à l'exécution. Notez également que le nombre d'exécutions figurant dans le résultat du plan d'exécution produit par SET STATISTICS PROFILE équivaut à la somme des reliaisons et des rembobinages des plans d'exécution produits par SET STATISTICS XML.|  
|![Icône d’opérateur Concatenation](../relational-databases/media/concatenation-32x.gif "Icône d’opérateur Concatenation")|**Concatenation**|L'opérateur **Concatenation** analyse plusieurs entrées et renvoie chaque ligne analysée. L'opérateur**Concatenation** sert généralement à implémenter la construction [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL. L'opérateur physique **Concatenation** a deux entrées ou plus, et une sortie. L'opérateur Concatenation copie des lignes depuis le premier flux d'entrée vers le flux de sortie, puis répète l'opération pour chacun des autres flux d'entrée. **Concatenation** est un opérateur logique et physique.|  
|![Icône d’opérateur Constant Scan](../relational-databases/media/constant-scan-32x.gif "Icône d’opérateur Constant Scan")|**Constant Scan**|L'opérateur **Constant Scan** introduit une ou plusieurs lignes de constante dans une requête. Un opérateur **Compute Scalar** est souvent utilisé après un opérateur **Constant Scan** pour ajouter des colonnes à une ligne produite par l'opérateur **Constant Scan** .|  
|![Icône de l’élément de langage Convert (moteur de base de données)](../relational-databases/media/convert-32x.gif "Icône de l’élément de langage Convert (moteur de base de données)")|**Convert**|L'opérateur **Convert** convertit une expression d'un type de données scalaire en un autre. **Convert** est un élément de langage.|  
|None|**Cross Join**|L’opérateur **Cross Join** relie chaque ligne de la première entrée (du haut) à chaque ligne de la deuxième entrée (du bas). **Cross Join** est un opérateur logique.|  
|![Icône d’opérateur Cursor Catchall](../relational-databases/media/cursor-catch-all.gif "Icône d’opérateur Cursor Catchall")|**catchall**|L'icône catchall s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les éléments du langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|None|**Curseur**|Les opérateurs physiques et logiques de **curseur** sont utilisés pour décrire le mode d'exécution d'une requête ou d'une mise à jour impliquant des opérations de curseur. Les opérateurs physiques décrivent l'algorithme d'implémentation physique utilisé pour traiter le curseur, par exemple, à l'aide d'un curseur contrôlé par clés. Chaque étape de l'exécution d'un curseur implique un opérateur physique. Les opérateurs logiques décrivent une propriété du curseur, par exemple, le curseur est en lecture seule.<br /><br /> Les opérateurs logiques incluent Asynchronous, Optimistic, Primary, Read Only, Scroll Locks et Secondary et Synchronous.<br /><br /> Les opérateurs physiques incluent Dynamic, Fetch Query, Keyset, Population Query, Refresh Query et Snapshot.|  
|![Icône de l’élément de langage Declare](../relational-databases/media/declare-32x.gif "Icône de l’élément de langage Declare")|**Declare**|L'opérateur **Declare**  alloue une variable locale dans le plan de requête. **Declare** est un élément de langage.|  
|![Icône d’opérateur Delete (moteur de base de données)](../relational-databases/media/delete-32x.gif "Icône d’opérateur Delete (moteur de base de données)")|**Supprimer**|L'opérateur **Delete** supprime d'un objet les lignes qui répondent au prédicat facultatif de la colonne **Argument** .|  
|![Icône d’opérateur Delete Scan](../relational-databases/media/delete-scan-32x.gif "Icône d’opérateur Delete Scan")|**Deleted Scan**|L'opérateur **Deleted Scan** analyse la table supprimée dans un déclencheur.|  
|None|**Distinct**|L'opérateur **Distinct** supprime les doublons d'un ensemble de lignes ou d'une collection de valeurs. **Distinct** est un opérateur logique.|  
|None|**Distinct Sort**|L’opérateur logique **Distinct Sort** analyse les entrées en éliminant les doublons et en triant les colonnes spécifiées dans le prédicat DISTINCT ORDER BY:() de la colonne **Argument** . **Distinct Sort** est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Distribute Streams](../relational-databases/media/parallelism-distribute-stream.gif "Icône d’opérateur de parallélisme Distribute Streams")|**Distribute Streams**|L'opérateur **Distribute Streams** est utilisé uniquement dans les plans de requête parallèles. L'opérateur **Distribute Streams** ne mobilise qu'un seul flux d'entrée d'enregistrements et produit plusieurs flux de sortie. Le contenu et le format des enregistrements ne sont pas modifiés. Chaque enregistrement provenant du flux d'entrée apparaît dans l'un des flux de sortie. Cet opérateur conserve automatiquement l'ordre relatif des enregistrements d'entrée dans les flux de sortie. Habituellement, le hachage est utilisé pour définir à quel flux de sortie appartient un enregistrement d'entrée particulier.<br /><br /> Si la sortie est partitionnée, la colonne **Argument** contient alors un prédicat PARTITION COLUMNS:() et les colonnes de partitionnement. **Distribute Streams** est un opérateur logique.|  
|![Icône d’opérateur de curseur Dynamic](../relational-databases/media/dynamic-32x.gif "Icône d’opérateur de curseur Dynamic")|**Dynamic**|L'opérateur **Dynamic** utilise un curseur capable de détecter toutes les modifications effectuées par d'autres utilisateurs.|  
|![Icône d’opérateur Spool](../relational-databases/media/spool-32x.gif "Icône d’opérateur Spool")|**Eager Spool**|L'opérateur **Eager Spool** utilise l'ensemble de l'entrée en stockant chaque ligne dans un objet temporaire masqué stocké dans la base de données **tempdb** . Si l’opérateur est réutilisé (par un opérateur **Nested Loops** , par exemple) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Eager Spool** crée le fichier spouleur avec « avidité » : lorsque l'opérateur parent du spool demande la première ligne, l'opérateur spool consomme toutes les lignes de son opérateur d'entrée et les stocke dans le spool. **Eager Spool** est un opérateur logique.|  
|![Icône d’opérateur de curseur Fetch Query](../relational-databases/media/fetch-query-32x.gif "Icône d’opérateur de curseur Fetch Query")|**Fetch Query**|L'opérateur **Fetch Query** extrait des lignes lorsqu'une extraction est émise à l'aide d'un curseur.|  
|![Icône d’opérateur Filter (moteur de base de données)](../relational-databases/media/filter-32x.gif "Icône d’opérateur Filter (moteur de base de données)")|**Filter**|L’opérateur **Filter** analyse l’entrée en ne retournant que les lignes répondant à l’expression du filtre (prédicat) qui apparaît dans la colonne **Argument** .|  
|None|**Flow Distinct**|L'opérateur logique **Flow Distinct** analyse les entrées en éliminant les doublons. Alors que l’opérateur **Distinct** mobilise l’intégralité des entrées avant de produire une sortie, l’opérateur **FlowDistinct** retourne chaque ligne à mesure qu’il l’obtient de l’entrée (sauf si la ligne est un doublon, auquel cas elle est supprimée).|  
|None|**Full Outer Join**|L’opérateur logique **Full Outer Join** retourne chaque ligne répondant au prédicat de jointure de la première entrée (du haut) joint à chaque ligne de la seconde entrée (du bas). Il renvoie également les lignes de :<br /><br /> -la première entrée qui ne possède pas de correspondance dans la seconde entrée ;<br /><br /> -la seconde entrée sans correspondance dans la première entrée.<br /><br /> L'entrée qui ne contient pas les valeurs correspondantes est retournée sous forme de valeur NULL. **Full Outer Join** est un opérateur logique.|  
|![Icône d’opérateur de parallélisme Gather Streams](../relational-databases/media/parallelism-32x.gif "Icône d’opérateur de parallélisme Gather Streams")|**Gather Streams**|L'opérateur **Gather Streams** n'est utilisé que dans les plans de requête parallèle. **Cet opérateur** mobilise plusieurs flux d'entrée et ne produit qu'un flux de sortie d'enregistrements en associant les flux d'entrée. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'opérateur conserve l'ordre, tous les flux d'entrée doivent alors être classés. Si la sortie est triée, la colonne **Argument** contient un prédicat ORDER BY:() et les noms des colonnes classées. **Gather Streams** est un opérateur logique.|  
|![Icône d’opérateur Hash Match](../relational-databases/media/hash-match-32x.gif "Icône d’opérateur Hash Match")|**Hash Match**|L'opérateur **Hash Match** crée une table de hachage en calculant une valeur de hachage pour chaque ligne à partir de son entrée de génération. Un prédicat HASH:() accompagné d’une liste de colonnes utilisées pour créer une valeur de hachage apparaît dans la colonne **Argument** . Ensuite, il calcule, pour chaque ligne de sondage (le cas échéant), une valeur de hachage en utilisant la même fonction de hachage, et consulte la table de hachage pour trouver les correspondances. Si un prédicat résiduel (identifié par RESIDUAL:() dans la colonne **Argument** ) y figure, il doit également trouver les lignes qui doivent lui correspondre. Son comportement dépend de l'opération logique exécutée :<br /><br /> -Pour toutes les jointures, utilisez la première entrée (du haut) pour créer la table de hachage, et la seconde entrée (du bas) pour tester cette table. Les correspondances (ou non correspondances) de sortie sont dictées par le type de jointure. Si plusieurs jointures utilisent la même colonne de jointure, ces opérations sont regroupées dans une équipe de hachage.<br /><br /> -Pour les opérateurs distincts ou d’agrégation, utilisez l’entrée pour créer la table de hachage (en supprimant les doublons et en calculant les expressions d’agrégation). Une fois la table de hachage construite, parcourez-la et sortez toutes les entrées.<br /><br /> -Pour l’opérateur UNION, utilisez la première entrée pour créer la table de hachage (en supprimant les doublons). Utilisez la deuxième entrée (qui ne doit pas comporter de doublons) pour analyser la table de hachage, retourner toutes les lignes sans correspondance, puis analyser la table de hachage et retourner toutes les entrées.<br /><br /> **Hash Match** est un opérateur physique.|  
|![Icône de l’élément de langage If](../relational-databases/media/if-32x.gif "Icône de l’élément de langage If")|**If**|L'opérateur **If** effectue un traitement conditionnel basé sur une expression. **If** est un élément de langage.|  
|None|**Inner Join**|L’opérateur logique **Inner Join** retourne chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde entrée (du bas).|  
|![Icône d’opérateur Insert (moteur de base de données)](../relational-databases/media/insert-32x.gif "Icône d’opérateur Insert (moteur de base de données)")|**Insert**|L'opérateur logique **Insert** insère chaque ligne de son entrée dans l'objet spécifié dans la colonne **Argument** . L'opérateur physique est l'opérateur **Table Insert**, **Index Insert**ou **Clustered Index Insert** .|  
|![Icône d’opérateur Inserted Scan](../relational-databases/media/inserted-scan-32x.gif "Icône d’opérateur Inserted Scan")|**Inserted Scan**|L'opérateur **Inserted Scan** analyse la table **insérée** . **Inserted Scan** est un opérateur logique et physique.|  
|![Icône de l’élément de langage Intrinsic](../relational-databases/media/intrinsic-32x.gif "Icône de l’élément de langage Intrinsic")|**Intrinsic**|L’opérateur **Intrinsic** appelle une fonction [!INCLUDE[tsql](../includes/tsql-md.md)] interne. **Intrinsic** est un élément de langage.|  
![Icône d’opérateur Iterator Catchall](../relational-databases/media/iterator-catch-all.gif "Icône d’opérateur Iterator Catchall")|**Iterator**|L'icône catchall **Iterator** s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur Bookmark Lookup](../relational-databases/media/bookmark-lookup-32x.gif "Icône d’opérateur Bookmark Lookup")|**Key Lookup**|L'opérateur **Key Lookup** est une recherche de signet sur une table avec un index cluster. La colonne **Argument** contient le nom de l'index cluster et la clé de clustering utilisée pour rechercher la ligne dans l'index cluster. **Key Lookup** est toujours accompagné par un opérateur **Nested Loops** . Si la clause WITH PREFETCH apparaît dans la colonne **Argument** , cela signifie que le processeur de requêtes a décidé que la prérécupération asynchrone (lecture anticipée) constitue la solution optimale pour la recherche de signets dans l’index cluster.<br /><br /> L'utilisation d'un opérateur **Key Lookup** dans un plan de requête indique que la requête peut bénéficier du réglage des performances. Par exemple, l'ajout d'un index explicatif peut améliorer les performances des requêtes.|  
|![Icône d’opérateur de curseur Keyset](../relational-databases/media/keyset-32x.gif "Icône d’opérateur de curseur Keyset")|**Keyset**|L'opérateur **Keyset** utilise un curseur qui peut détecter les mises à jour, mais pas les insertions effectuées par d'autres.|  
|![Icône catchall Language Element](../relational-databases/media/language-construct-catch-all.gif "Icône catchall Language Element")|**Language Element**|L'icône catchall **Language Element** s'affiche lorsque la logique qui produit des plans de requête graphiques ne parvient pas à trouver une icône adaptée pour l'itérateur. Cette icône n'indique pas nécessairement une condition d'erreur. Il existe trois types d'icône catchcall : bleu (pour les itérateurs), orange (pour les curseurs) et vert (pour les constructions de langage [!INCLUDE[tsql](../includes/tsql-md.md)] ).|  
|![Icône d’opérateur Spool](../relational-databases/media/spool-32x.gif "Icône d’opérateur Spool")|**Lazy Spool**|L'opérateur logique **Lazy Spool** stocke chaque ligne de son entrée dans un objet temporaire masqué, lui-même stocké dans la base de données **tempdb** . Si l’opérateur est réutilisé (par un opérateur **Nested Loops** , par exemple) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. Si une nouvelle liaison est nécessaire, les données mises en attente sont supprimées et l'objet en attente est recréé par une nouvelle analyse de l'entrée (liée une nouvelle fois). L'opérateur **Lazy Spool** crée son fichier d'attente de manière « économique » : chaque fois que l'opérateur parent du fichier d'attente demande une ligne, l'opérateur en attente obtient une ligne de son opérateur d'entrée et la stocke dans le fichier d'attente, au lieu de consommer toutes les lignes simultanément. Lazy Spool est un opérateur logique.|  
|None|**Left Anti Semi Join**|L’opérateur **Left Anti Semi Join** retourne chaque ligne de la première entrée (du haut) lorsqu’il n’y a aucune ligne correspondante dans la seconde entrée (du bas). Si aucun prédicat de jointure n'est présent dans la colonne **Argument** , chaque ligne est une ligne correspondante. **Left Anti Semi Join** est un opérateur logique.|  
|None|**Left Outer Join**|L’opérateur logique **Left Outer Join** renvoie chaque ligne répondant à la jointure de la première entrée (du haut) et de la seconde entrée (du bas). Il renvoie également toute ligne de la première entrée n'ayant pas de ligne en correspondance dans la seconde entrée. Les lignes sans correspondance dans la seconde entrée sont retournées sous forme de valeurs NULL. Si aucun prédicat de jointure n'est présent dans la colonne **Argument** , chaque ligne est une ligne correspondante. **Left Outer Join** est un opérateur logique.|  
|None|**Left Semi Join**|L’opérateur **Left Semi Join** retourne chaque ligne de la première entrée (du haut) lorsqu’il y a une ligne correspondante dans la seconde entrée (du bas). Si aucun prédicat de jointure n'est présent dans la colonne **Argument** , chaque ligne est une ligne correspondante. **Left Semi Join** est un opérateur logique.|  
|![Icône d’opérateur Log Row Scan](../relational-databases/media/log-row-scan-32x.gif "Icône d’opérateur Log Row Scan")|**Log Row Scan**|L'opérateur **Log Row Scan** analyse le journal des transactions. **Log Row Scan** est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Interval](../relational-databases/media/merge-interval-32x.gif "Icône d’opérateur Merge Interval")|**Merge Interval**|L’opérateur **Merge Interval** fusionne plusieurs intervalles (susceptibles de se chevaucher) pour produire des intervalles minimaux qui ne se chevauchent pas, intervalles qui seront ensuite utilisés pour rechercher des entrées d’index. Cet opérateur apparaît généralement au-dessus d’un ou plusieurs opérateurs **Compute Scalar** sur des opérateurs **Constant Scan** , qui créent les intervalles (représentés sous forme des colonnes d’une ligne) que l’opérateur fusionne. **Merge Interval** est un opérateur logique et physique.|  
|![Icône d’opérateur Merge Join](../relational-databases/media/merge-join-32x.gif "Icône d’opérateur Merge Join")|**Merge Join**|L'opérateur **Merge Join** exécute les opérations logiques suivantes : inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join et union.<br /><br /> Dans la colonne **Argument** , l’opérateur **Merge Join** contient un prédicat MERGE:() si l’opération exécute une jointure un-à-plusieurs, ou un prédicat MANY-TO-MANY MERGE:() si l’opération exécute une jointure plusieurs-à-plusieurs. La colonne **Argument** inclut également une liste de colonnes séparées par des virgules utilisées pour exécuter l’opération. L'opérateur **Merge Join** nécessite deux entrées triées dans leurs colonnes respectives, peut-être par l'insertion d'opérations de tri explicites dans le plan de requête. L'opérateur Merge join est particulièrement efficace si le tri explicite n'est pas nécessaire, par exemple s'il existe un index B-tree approprié dans la base de données ou si l'ordre de tri peut être exploité pour plusieurs opérations, telles que jointure de fusion et regroupement par cumuls. **Merge Join** est un opérateur physique.|  
|![Icône d’opérateur Nested Loops](../relational-databases/media/nested-loops-32x.gif "Icône d’opérateur Nested Loops")|**Nested Loops**|L'opérateur **Nested Loops** réalise les opérations logiques Inner Join, Left Outer Join, Left Semi Join et Left Anti Semi Join. Les jointures de boucles imbriquées effectuent une recherche sur la table interne pour chaque ligne de la table externe, généralement en utilisant un index. Le processeur de requêtes décide, sur la base des coûts anticipés, de trier ou non l’entrée externe pour améliorer la localisation des recherches dans l’index de l’entrée interne. Les lignes répondant au prédicat (facultatif) de la colonne **Argument** sont renvoyées (le cas échéant, sur la base de l’opération logique exécutée). **Nested Loops** est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Delete](../relational-databases/media/nonclust-index-delete-32x.gif "Icône d’opérateur Nonclustered Index Delete")|**Nonclustered Index Delete**|L'opérateur **Nonclustered Index Delete** supprime des lignes d'entrée de l'index non-cluster spécifié dans la colonne **Argument** . **Nonclustered Index Delete** est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Insert](../relational-databases/media/nonclust-index-insert-32x.gif "Icône d’opérateur Nonclustered Index Insert")|**Index Insert**|L'opérateur **Index Insert** insère des lignes de son entrée dans l'index non-cluster spécifié dans la colonne **Argument** . La colonne **Argument** contient également un prédicat SET:(), qui indique la valeur à laquelle chaque colonne est définie. **Index Insert** est un opérateur physique.|  
|![Icône d’opérateur Nonclustered Index Scan](../relational-databases/media/nonclustered-index-scan-32x.gif "Icône d’opérateur Nonclustered Index Scan")|**Index Scan**|L'opérateur **Index Scan** récupère toutes les lignes de l'index non-cluster spécifié dans la colonne **Argument** . Si un prédicat WHERE:() facultatif figure dans la colonne **Argument** , seules les lignes répondant à ce prédicat sont retournées. **Index Scan** est un opérateur logique et physique.|  
|![Icône d’opérateur Nonclustered Index Seek](../relational-databases/media/index-seek-32x.gif "Icône d’opérateur Nonclustered Index Seek")|**Index Seek**|L'opérateur **Index Seek** utilise la capacité de recherche dans les index pour extraire des lignes d'un index non-cluster. La colonne **Argument** contient le nom de l'index non-cluster utilisé. Il contient également le prédicat SEEK:(). Le moteur de stockage utilise l'index pour ne traiter que les lignes répondant au prédicat SEEK:(). Il peut éventuellement inclure un prédicat WHERE:() dans lequel le moteur de stockage est évalué par rapport à toutes les lignes répondant au prédicat SEEK:() ; il ne fait pas appel aux index pour exécuter ce processus. Si la colonne **Argument** contient la clause ORDERED, cela signifie que le processeur de requêtes a décidé que les lignes devaient être retournées dans l'ordre dans lequel l'index non-cluster les a triées. Si la clause ORDERED n'apparaît pas, le moteur de stockage recherche dans l'index de façon optimale (sans garantie de tri de la sortie). Autoriser la sortie à conserver son ordre peut s'avérer moins efficace que la production d'une sortie non triée. **Index Seek** est un opérateur logique et physique.|  
|![Icône d’opérateur Nonclustered Index Spool](../relational-databases/media/index-spool-32x.gif "Icône d’opérateur Nonclustered Index Spool")|**Index spool**|L’opérateur physique **Index Spool** contient un prédicat SEEK:() dans la colonne **Argument** . L’opérateur **Index Spool** analyse ses lignes d’entrée en plaçant une copie de chaque ligne dans un fichier d’attente caché (stocké dans la base de données **tempdb** et qui n’existe que le temps de la requête) et construit un index non-cluster sur les lignes. Ceci vous permet d'utiliser les capacités de recherche des index afin de ne sortir que les lignes répondant au prédicat SEEK:(). Si l’opérateur est réutilisé (par un opérateur **Nested Loops** , par exemple) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée.|  
|![Icône d’opérateur Nonclustered Index Update](../relational-databases/media/nonclust-index-update-32x.gif "Icône d’opérateur Nonclustered Index Update")|**Nonclustered Index Update**|L'opérateur physique **Nonclustered Index Update** met à jour des lignes de son entrée dans l'index non-cluster spécifié dans la colonne **Argument** . Si un prédicat SET:() est présent, chaque colonne mise à jour prend cette valeur. **Nonclustered Index Update** est un opérateur physique.|  
|![Icône d’opérateur Online Index Insert](../relational-databases/media/online-index-32x.gif "Icône d’opérateur Online Index Insert")|**Online Index Insert**|L'opérateur physique **Online Index Insert** indique qu'une opération de création, modification ou suppression d'index est effectuée en ligne. Autrement dit, les données de la table sous-jacente restent disponibles aux utilisateurs pendant l'opération d'index.|  
|None|**Parallelism**|L'opérateur **Parallelism** (ou itérateur d’échange) effectue les opérations logiques de distribution de flux, de collecte de flux, et de répartition de flux. La colonne **Argument** peut contenir un prédicat PARTITION COLUMNS:() avec la liste des colonnes de partitionnement séparées par des virgules. La colonne **Argument** peut également contenir un prédicat ORDER BY:(), qui liste les colonnes pour conserver l’ordre de tri durant le partitionnement. **Parallelism** est un opérateur physique. Pour plus d’informations sur l’opérateur Parallelism, consultez la [série de blogs de Craig Freedman](http://blogs.msdn.microsoft.com/craigfr/tag/parallelism/).<br /><br />**Remarque :** si une requête a été compilée en tant que requête parallèle, mais qu’au moment de son exécution elle est exécutée comme une requête séquentielle, les données de sortie du plan d’exécution de requêtes générées par SET STATISTICS XML ou au moyen de l’option **Inclure le plan d’exécution réel** de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] ne contiendront pas l’élément **RunTimeInformation** pour l’opérateur **Parallelism**. Dans le résultat de SET STATISTICS PROFILE, les compteurs de lignes réelles et le nombre réel d'exécutions afficheront des zéros pour l'opérateur **Parallelism** . Si l’une ou l’autre de ces situations se produit, cela signifie que l’opérateur **Parallelism** n’a été utilisé que lors de la compilation de la requête, mais pas dans le plan de requête en cours d’exécution. Notez que certaines fois, les plans de requête parallèles sont exécutés séquentiellement si le serveur doit faire face à des charges concurrentes élevées.|  
|![Icône d’opérateur Parameter Table Scan](../relational-databases/media/parameter-table-scan-32x.gif "Icône d’opérateur Parameter Table Scan")|**Parameter Table Scan**|L'opérateur **Parameter Table Scan** analyse une table qui agit comme paramètre dans la requête en cours. Généralement, cet opérateur est utilisé dans une procédure stockée pour les requêtes INSERT. **Parameter Table Scan** est un opérateur logique et physique.|  
|None|**Partial Aggregate**|**Partial Aggregate** est utilisé dans des plans parallèles. Il applique une fonction d'agrégation à autant de lignes d'entrée que possible, afin que l'écriture sur le disque (appelé « débordement ») ne soit pas nécessaire. **Hash Match** constitue l’unique opérateur physique (itérateur) qui implémente une agréation de partition. **Partial Aggregate** est un opérateur logique.|  
|![Icône d’opérateur de curseur Population Query](../relational-databases/media/poulation-query-32x.gif "Icône d’opérateur de curseur Population Query")|**Population Query**|L'opérateur **Population Query** permet de renseigner la table de travail d'un curseur lorsque le curseur est ouvert.|  
|![Icône d’opérateur de curseur Refresh Query](../relational-databases/media/refresh-query-32x.gif "Icône d’opérateur de curseur Refresh Query")|**Refresh Query**|L'opérateur **Refresh Query** extrait les données courantes des lignes du tampon d'extraction.|  
|![Icône d’opérateur Remote Delete](../relational-databases/media/remote-delete-32x.gif "Icône d’opérateur Remote Delete")|**Remote Delete**|L'opérateur **Remote Delete** supprime les lignes d'entrée d'un objet distant. **Remote Delete** est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Scan](../relational-databases/media/remote-index-scan-32x.gif "Opérateur Showplan Remote Index Scan")|**Remote Index Scan**|L’opérateur **Remote Index Scan** analyse l’index distant spécifié dans la colonne Argument. **Remote Index Scan** est un opérateur logique et physique.|  
|![Opérateur Showplan Remote Index Seek](../relational-databases/media/remote-index-seek-32x.gif "Opérateur Showplan Remote Index Seek")|**Remote Index Seek**|L'opérateur **Remote Index Seek** utilise les capacités de recherche d'un objet d'index distant pour extraire des lignes. La colonne **Argument** contient le nom de l’index distant utilisé et le prédicat SEEK:(). **Remote Index Seek** est un opérateur physique logique.|  
|![Icône d’opérateur Remote Insert](../relational-databases/media/remote-insert-32x.gif "Icône d’opérateur Remote Insert")|**Remote Insert**|L'opérateur **Remote Insert** insère des lignes d'entrée dans un objet distant. **Remote Insert** est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Query](../relational-databases/media/remote-query-32x.gif "Icône d’opérateur Remote Query")|**Remote Query**|L'opérateur **Remote Query** soumet une requête à une source distante. Le texte de la requête envoyée au serveur distant apparaît dans la colonne **Argument** . **Remote Query** est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Scan](../relational-databases/media/remote-scan-32x.gif "Icône d’opérateur Remote Scan")|**Remote Scan**|L'opérateur **Remote Scan** analyse un objet distant. Le nom de l'objet distant apparaît dans la colonne **Argument** . **Remote Scan** est un opérateur logique et physique.|  
|![Icône d’opérateur Remote Update](../relational-databases/media/remote-update-32x.gif "Icône d’opérateur Remote Update")|**Remote Update**|L'opérateur **Remote Update** met à jour les lignes d'entrée dans un objet distant. **Remote Update** est un opérateur logique et physique.|  
|![Icône d’opérateur de parallélisme Repartition Streams](../relational-databases/media/parallelism-repartition-stream.gif "Icône d’opérateur de parallélisme Repartition Streams")|**Repartition Streams**|L'opérateur **Repartition Streams** (ou itérateur d’échange) consomme plusieurs flux et produit plusieurs flux d'enregistrements. Le contenu et le format des enregistrements ne sont pas modifiés. Si l'optimiseur de requête utilise un filtre bitmap, le nombre de lignes dans le flux de sortie est réduit. Chaque enregistrement d'un flux d'entrée est placé dans un flux de sortie. Si l'opérateur conserve l'ordre de tri, tous les flux d'entrée seront classés et fusionnés en plusieurs flux de sortie triés. Si la sortie est partitionnée, la colonne **Argument** contient un prédicat PARTITION COLUMNS:() et les colonnes de partitionnement. Si la sortie est triée, la colonne **Argument** contient un prédicat ORDER BY:() et les colonnes triées. **Repartition Streams** est un opérateur logique. Cet opérateur n'est utilisé que dans les plans de requête en parallèle.| 
|![Icône de l’élément de langage Result](../relational-databases/media/result-32x.gif "Icône de l’élément de langage Result")|**Result**|L'opérateur **Result** contient les données retournées à la fin d'un plan de requête. Il représente en général l'élément racine d'un plan d'exécution de requêtes. **Result** est un élément de langage.|  
|![Icône d’opérateur RID Lookup](../relational-databases/media/rid-nonclust-locate-32x.gif "Icône d’opérateur RID Lookup")|**RID Lookup**|**RID Lookup** est une recherche de signet sur un segment utilisant un identificateur de ligne fourni (RID, Row Identifier). La colonne **Argument** contient l'étiquette de signet utilisée pour rechercher la ligne dans la table, ainsi que le nom de la table dans laquelle la ligne est recherchée. **RID Lookup** est toujours accompagné par un opérateur NESTED LOOP JOIN. **RID Lookup** est un opérateur physique. Pour plus d'informations sur les recherches de signets, consultez «[Bookmark Lookup](http://go.microsoft.com/fwlink/?LinkId=132568)» (en anglais) sur le blog MSDN SQL Server.|  
|None|**Right Anti Semi Join**|L’opérateur **Right Anti Semi Join** extrait chaque ligne de la seconde entrée (en bas) lorsqu’il n’existe pas de ligne correspondante dans la première entrée (en haut). Une ligne correspondante se définit comme une ligne répondant au prédicat de la colonne **Argument** (s’il n’y a pas de prédicat, chaque ligne est une ligne correspondante). **Right Anti Semi Join** est un opérateur logique.|  
|None|**Right Outer Join**|L’opérateur **Right Outer Join** retourne chaque ligne répondant à la condition de jointure de la seconde entrée (du bas) avec chaque ligne correspondante dans la première entrée (du haut). Il retourne également toutes les lignes de la seconde entrée qui n'ont pas de lignes correspondantes dans la première entrée, reliées par la valeur NULL. Si aucun prédicat de jointure n'est présent dans la colonne **Argument** , chaque ligne est une ligne correspondante. **Right Outer Join** est un opérateur logique.|  
|None|**Right Semi Join**|L’opérateur **Right Semi Join** renvoie chaque ligne de la seconde entrée (du bas) lorsqu’il y a une ligne correspondante dans la première entrée (du haut). Si aucun prédicat de jointure n'est présent dans la colonne **Argument** , chaque ligne est une ligne correspondante. **Right Semi Join** est un opérateur logique.|  
|![Icône d’opérateur Row Count Spool](../relational-databases/media/remote-count-spool-32x.gif "Icône d’opérateur Row Count Spool")|**Row Count Spool**|L'opérateur **Row Count Spool** analyse l'entrée en comptant le nombre de lignes présentes et en retournant ce même nombre de lignes exemptes de données. Cet opérateur est utilisé lorsqu'il est plus important de vérifier l'existence des lignes que les données qu'elles contiennent. Par exemple, si un opérateur **Nested Loops** exécute une opération Left Semi Joint et que le prédicat de jointure s'applique à l'entrée interne, un spool du nombre de lignes peut être placé en haut de l'entrée interne de l'opérateur **Nested Loops** . L’opérateur **Nested Loops** peut alors déterminer le nombre de lignes sorties par l’opérateur Row Count Spool (car les données réelles de la partie interne ne sont pas indispensables) afin d’établir s’il doit renvoyer ou non la ligne externe. **Row Count Spool** est un opérateur physique.|  
|![Icône d’opérateur Segment](../relational-databases/media/segment-32x.gif "Icône d’opérateur Segment")|**Segment**|**Segment** est un opérateur logique et physique. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. Ces colonnes apparaissent en tant qu'arguments dans l'opérateur **Segment** . L'opérateur génère ensuite un segment à la fois.|  
|None|**Segment Repartition**|Dans un plan de requête parallèle, il existe parfois des régions conceptuelles composées d'itérateurs. Tous les itérateurs de ces régions peuvent être exécutés par des threads parallèles. Les régions elles-mêmes doivent être exécutées séquentiellement. Certains itérateurs **Parallelism** d'une région distincte sont appelés **Branch Repartition**. L'itérateur **Parallelism** situé à la limite de deux régions de ce type est appelé **Segment Repartition**. **Branch Repartition** et **Segment Repartition** sont des opérateurs logiques.|  
|![Icône d’opérateur Sequence](../relational-databases/media/sequence-32x.gif "Icône d’opérateur Sequence")|**Sequence**|L'opérateur **Sequence** gère des plans de mise à jour étendus. Il exécute, sur le plan fonctionnel, chaque entrée en séquence (de haut en bas). Chaque entrée est généralement une mise à jour d'un objet différent. Il ne retourne que les lignes provenant de sa dernière entrée (du bas). **Sequence** est un opérateur logique et physique.|  
|![Icône d’opérateur Sequence Project](../relational-databases/media/sequence-project-32x.gif "Icône d’opérateur Sequence Project")|**Sequence Project**|L'opérateur **Sequence Project** ajoute des colonnes pour effectuer des calculs sur un jeu ordonné. Il divise le jeu d'entrée en segments en fonction de la valeur d'une ou plusieurs colonnes. L'opérateur génère ensuite un segment à la fois. Ces colonnes s'affichent en tant qu'arguments dans l'opérateur **Sequence Project** . **Sequence Project** est un opérateur logique et physique.|  
|![Icône d’opérateur de curseur Snapshot](../relational-databases/media/snapshot-32x.gif "Icône d’opérateur de curseur Snapshot")|**Snapshot**|L'opérateur **Snapshot** crée un curseur qui ne voit pas les modifications apportées par les autres.|  
|![Icône d’opérateur Sort](../relational-databases/media/sort-32x.gif "Icône d’opérateur Sort")|**Sort**|L'opérateur **Sort** trie toutes les lignes entrantes. La colonne **Argument** contient soit un prédicat DISTINCT ORDER BY:() si les doublons sont supprimés par cette opération, soit un prédicat ORDER BY:() accompagné de la liste des colonnes à trier séparées par des virgules. Les colonnes comportent le préfixe ASC si elles sont triées dans l'ordre ascendant, ou DESC si elles sont triées dans l'ordre descendant. **Sort** est un opérateur logique et physique.|  
|![Icône d’opérateur Split](../relational-databases/media/split-32x.gif "Icône d’opérateur Split")|**Split**|L'opérateur **Split** est utilisé pour optimiser le traitement des mises à jour. Il divise chaque opération de mise à jour en opérations DELETE et INSERT. L'opérateur**Split** est un opérateur logique et physique.|  
|![Icône d’opérateur Spool](../relational-databases/media/spool-32x.gif "Icône d’opérateur Spool")|**Spool**|L'opérateur **Spool** enregistre un résultat de requête intermédiaire dans la base de données **tempdb** .|  
|![Icône d’opérateur Stream Aggregate](../relational-databases/media/stream-aggregate-32x.gif "Icône d’opérateur Stream Aggregate")|**Stream Aggregate**|L'opérateur **Stream Aggregate** effectue un regroupement d'après une ou plusieurs colonnes et calcule une ou plusieurs expressions d'agrégation retournées par la requête. La sortie de cet opérateur peut être référencée par des opérateurs ultérieurs dans la requête, retournés au client, ou les deux. L'opérateur **Stream Aggregate** exige que l'entrée suive l'ordre des colonnes dans ses groupes. L'optimiseur utilise un opérateur **Sort** avant cet opérateur si les données ne sont pas déjà triées en raison d'un opérateur **Sort** précédent ou d'une recherche ou d'une analyse d'index triée. Dans l’instruction SHOWPLAN_ALL ou dans le plan d’exécution graphique de [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], les colonnes du prédicat GROUP BY sont répertoriées dans la colonne **Argument** , et les expressions d’agrégation sont répertoriées dans la colonne **Defined Values** . **Stream Aggregate** est un opérateur physique.|  
|![Icône d’opérateur Switch](../relational-databases/media/switch-32x.gif "Icône d’opérateur Switch")|**Switch**|**Switch** est un type particulier d'itérateur de concaténation qui a *n* entrées. Une expression est associée à chaque opérateur **Switch** . Selon la valeur renvoyée par l’expression (entre 0 et *n*-1), **Switch** copie le flux d’entrée approprié dans le flux de sortie. L'une des utilisations de **Switch** consiste à implémenter des plans de requête impliquant des curseurs à avance rapide avec certains opérateurs tels que l'opérateur **TOP** . **Switch** est un opérateur logique et physique.|  
|![Icône d’opérateur Table Delete](../relational-databases/media/table-delete-32x.gif "Icône d’opérateur Table Delete")|**Table Delete**|L'opérateur physique **Table Delete** supprime les lignes de la table spécifiée dans la colonne **Argument** du plan d'exécution de requête.|  
|![Icône d’opérateur Table Insert](../relational-databases/media/table-insert-32x.gif "Icône d’opérateur Table Insert")|**Table Insert**|L'opérateur **Table Insert** insère les lignes de son entrée dans la table spécifiée dans la colonne **Argument** du plan d'exécution de requête. La colonne **Argument** contient également un prédicat SET:(), qui indique la valeur à laquelle chaque colonne est définie. Si **Table Insert** ne possède pas d'enfant pour les valeurs insert, la ligne insérée est extraite de l'opérateur Insert lui-même. **Table Insert** est un opérateur physique.|  
|![Opérateur Table Merge](../relational-databases/media/table-merge-32x.gif "Opérateur Table Merge")|**Table Merge**|L'opérateur **Table Merge** applique un flux de données de fusion à un tas. L'opérateur supprime, met à jour ou insère des lignes dans la table spécifiée dans la colonne **Argument** de l'opérateur. L’opération réellement effectuée dépend de la valeur d’exécution de la colonne **ACTION** spécifiée dans la colonne **Argument** de l’opérateur. **Table Merge** est un opérateur physique.|  
|![Icône d’opérateur Table Scan](../relational-databases/media/table-scan-32x.gif "Icône d’opérateur Table Scan")|**Table Scan**|L'opérateur **Table Scan** extrait toutes les lignes de la table spécifiée dans la colonne **Argument** du plan d'exécution de requête. Si un prédicat WHERE:() figure dans la colonne **Argument** , seules les lignes répondant à ce prédicat sont retournées. **Table Scan** est un opérateur logique et physique.|  
|![Icône d’opérateur Table Spool](../relational-databases/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|**Table Spool**|L'opérateur **Table Spool** analyse l'entrée et place une copie de chaque ligne dans une table d'attente cachée, qui est stockée dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) et qui n'existe que le temps de la requête. Si l’opérateur est réutilisé (par un opérateur **Nested Loops** , par exemple) mais qu’aucune nouvelle liaison n’est nécessaire, les données mises en attente sont utilisées au lieu d’une nouvelle analyse de l’entrée. **Table Spool** est un opérateur physique.|  
|![Icône d’opérateur Table Update](../relational-databases/media/table-update-32x.gif "Icône d’opérateur Table Update")|**Table Update**|L'opérateur physique **Table Update** met à jour les lignes d'entrée de la table spécifiée dans la colonne **Argument** du plan d'exécution de requête. Le prédicat SET:() détermine la valeur de chaque colonne mise à jour. Ces valeurs peuvent être référencées dans la clause SET ou ailleurs dans cet opérateur et ailleurs dans cette requête.|  
|![Icône d’opérateur Table-valued Function](../relational-databases/media/table-valued-function-32x.gif "Icône d’opérateur Table-valued Function")|**Table-valued Function**|L’opérateur **Table-valued Function** évalue une fonction table ( [!INCLUDE[tsql](../includes/tsql-md.md)] ou CLR) et stocke les lignes obtenues dans la base de données [tempdb](../relational-databases/databases/tempdb-database.md) . Lorsque les itérateurs parents demandent les lignes, **Table-valued Function** renvoie les lignes à partir de **tempdb**.<br /><br /> Les requêtes avec des appels à des fonctions table génèrent des plans de requêtes avec l’itérateur **Table-valued Function** . La**fonction table** peut être évaluée avec différentes valeurs de paramètres :<br /><br /> -<br />                    **Lecteur XML de fonctions table** entre un BLOB XML en guise de paramètre et produit un ensemble de lignes représentant des nœuds XML dans l’ordre des documents XML. D'autres paramètres d'entrée peuvent limiter les nœuds XML renvoyés à un sous-ensemble d'un document XML.<br /><br /> -**Lecteur XML de fonctions table avec filtre XPath** est un type spécial de **Fonction table de lecteur XML** qui limite la sortie aux nœuds XML qui satisfont à une expression XPath.<br /><br /> **Table-valued Function** est un opérateur logique et physique.|  
|![Icône d’opérateur Top](../relational-databases/media/top-32x.gif "Icône d’opérateur Top")|**Top**|L'opérateur **Top** analyse l'entrée et retourne uniquement le premier nombre ou pourcentage spécifié de lignes, éventuellement en fonction d'un ordre de tri. La colonne **Argument** peut contenir la liste des colonnes dont les liaisons sont vérifiées. Dans les plans de mise à jour, l'opérateur **Top** renforce les limites du nombre de lignes. **Top** est un opérateur logique et physique.|  
|None|**Top N Sort**|L'itérateur**Top N Sort** est similaire à l'itérateur **Sort** , à la différence que seules les *N* premières lignes sont requises, et non pas la totalité de l'ensemble de résultats. Pour de petites valeurs de *N*, le moteur d'exécution de requête de [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] essaie de réaliser en mémoire la totalité de l'opération de tri. Pour des valeurs élevées de *N*, le moteur d'exécution de requête recourt à la méthode de tri plus générique, dans laquelle *N* n'est pas un paramètre.|  
|![Icône d’opérateur UDX (Extended)](../relational-databases/media/udx-32x.gif "Icône d’opérateur UDX (Extended)")|**UDX**|Les opérateurs UDX (Extended Operators) implémentent l'une des nombreuses opérations XQuery et XPath dans [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Tous les opérateurs UDX sont des opérateurs logiques et physiques.<br /><br /> L’opérateur UDX **FOR XML** est utilisé pour sérialiser l’ensemble de lignes relationnelles qu’il entre dans la représentation XML dans une colonne BLOB dans une ligne de sortie. Il s'agit d'un opérateur d'agrégation XML qui tient compte de l'ordre.<br /><br /> L’opérateur UDX **XML SERIALIZER** est un opérateur d’agrégation XML qui tient compte de l’ordre. Il entre des lignes qui représentent des nœuds XML ou des valeurs scalaires XQuery dans un ordre de document XML et produit un objet BLOB XML sérialisé dans une colonne XML dans une ligne de sortie.<br /><br /> L’opérateur UDX **XML FRAGMENT SERIALIZER** est un type spécial de **XML SERIALIZER** qui permet de traiter les lignes d’entrée représentant les fragments XML à insérer dans l’extension de modification de données d’insertion XQuery.<br /><br /> L’opérateur UDX **XQUERY STRING** évalue la valeur de la chaîne XQuery des lignes d’entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient la valeur de chaîne de l'entrée.<br /><br /> L’opérateur UDX **XQUERY LIST DECOMPOSER** est un opérateur de décomposition de liste XQuery. Pour chaque ligne d'entrée représentant un nœud XML, il produit une ou plusieurs lignes représentant chacune une valeur scalaire contenant une valeur d'élément de liste si le type d'entrée est une liste XSD.<br /><br /> L’opérateur UDX **XQUERY DATA** évalue la fonction XQuery fn:data() dans l’entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:data()**.<br /><br /> L’opérateur UDX **XQUERY CONTAINS** évalue la fonction XQuery fn:contains() dans l’entrée représentant des nœuds XML. Il s'agit d'un opérateur d'agrégation de chaîne qui tient compte de l'ordre. Il produit une ligne avec des colonnes représentant la valeur scalaire XQuery qui contient le résultat de **fn:contains()**.<br /><br /> L’opérateur étendu **UPDATE XML NODE** met à jour un nœud XML dans l’extension de modification de données de remplacement XQuery dans la méthode **modify()** dans le type XML.|  
|None|**Union**|L'opérateur **Union** analyse plusieurs entrées en sortant chaque ligne analysée et en supprimant les doublons. **Union** est un opérateur logique.|  
|![Icône d’opérateur Update (moteur de base de données)](../relational-databases/media/update-32x.gif "Icône d’opérateur Update (moteur de base de données)")|**Update**|L'opérateur **Update** met à jour chaque ligne de son entrée dans l'objet spécifié dans la colonne **Argument** du plan d'exécution de requête. **Update** est un opérateur logique. L'opérateur physique est **Table Update**, **Index Update**ou **Clustered Index Update**.|  
|![Icône de l’élément de langage While](../relational-databases/media/while-32x.gif "Icône de l’élément de langage While")|**While**|L’opérateur **While** implémente la boucle while [!INCLUDE[tsql](../includes/tsql-md.md)] . **While** est un élément de langage.|  
|![Icône d’opérateur Table Spool](../relational-databases/media/table-spool-32x.gif "Icône d’opérateur Table Spool")|**Window Spool**|L'opérateur **Window Spool** développe chaque ligne dans un ensemble de lignes qui représente la fenêtre qui lui est associée. Dans une requête, la clause OVER définit la fenêtre dans un jeu de résultats de la requête et une fonction de fenêtre calcule ensuite une valeur pour chaque ligne de la fenêtre. **Window Spool** est un opérateur logique et physique.|  
  
  
