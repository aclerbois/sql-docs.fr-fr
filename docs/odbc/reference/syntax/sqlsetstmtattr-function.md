---
title: Fonction SQLSetStmtAttr | Documents Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.suite: sql
ms.technology: connectivity
ms.tgt_pltfrm: ''
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: 32
author: MightyPen
ms.author: genemi
manager: craigg
ms.openlocfilehash: c41627051400b5b69573023b1bd20bf230ee2f86
ms.sourcegitcommit: 1740f3090b168c0e809611a7aa6fd514075616bf
ms.translationtype: MT
ms.contentlocale: fr-FR
ms.lasthandoff: 05/03/2018
---
# <a name="sqlsetstmtattr-function"></a>Fonction SQLSetStmtAttr
**Mise en conformité**  
 Version introduite : Conformité des normes 3.0 de ODBC : ISO 92  
  
 **Résumé**  
 **SQLSetStmtAttr** définit les attributs associés à une instruction.  
  
> [!NOTE]  
>  Pour plus d’informations sur ce que le Gestionnaire de pilotes mappe cette fonction pour lorsqu’un ODBC 3 *.x* application fonctionne avec une API ODBC 2 *.x* pilote, consultez [mappage des fonctions de remplacement pour la compatibilité descendante des Applications](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Syntaxe  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Arguments  
 *Au paramètre StatementHandle*  
 [Entrée] Descripteur d’instruction.  
  
 *Attribut*  
 [Entrée] Option permettant de définir, répertoriés dans « Commentaires ».  
  
 *ValuePtr*  
 [Entrée] Valeur à associer à *attribut*. Selon la valeur de *attribut*, *ValuePtr* aura l’une des opérations suivantes :  
  
-   Un handle de descripteur ODBC.  
  
-   Une valeur SQLUINTEGER.  
  
-   Une valeur SQLULEN.  
  
-   Pointeur vers une des valeurs suivantes :  
  
    -   Une chaîne de caractères terminée par null.  
  
    -   Une mémoire tampon binaire.  
  
    -   Une valeur ou un tableau de type SQLLEN, SQLULEN ou SQLUSMALLINT.  
  
    -   Une valeur définie par le pilote.  
  
 Si le *attribut* argument est une valeur spécifique au pilote, *ValuePtr* peut être un entier signé.  
  
 *stringLength*  
 [Entrée] Si *attribut* est un attribut défini par ODBC et *ValuePtr* pointe vers une chaîne de caractères ou d’un tampon binaire, cet argument doit être la longueur de \* *ValuePtr*. Si *attribut* est un attribut défini par ODBC et *ValuePtr* est un entier, *StringLength* est ignoré.  
  
 Si *attribut* est un attribut définies par le pilote, l’application indique la nature de l’attribut pour le Gestionnaire de pilotes en définissant le *StringLength* argument. *StringLength* peut avoir les valeurs suivantes :  
  
-   Si *ValuePtr* est un pointeur vers une chaîne de caractères, puis *StringLength* est la longueur de la chaîne ou le SQL_NTS.  
  
-   Si *ValuePtr* est un pointeur vers une mémoire tampon binaire, puis l’application place le résultat de la SQL_LEN_BINARY_ATTR (*longueur*) macro dans *StringLength*. Il s’ensuit une valeur négative dans *StringLength*.  
  
-   Si *ValuePtr* est un pointeur vers une valeur autre qu’une chaîne de caractères ou une chaîne binaire, puis *StringLength* doit avoir la valeur SQL_IS_POINTER.  
  
-   Si *ValuePtr* contient une valeur de longueur fixe, puis *StringLength* est SQL_IS_INTEGER ou SQL_IS_UINTEGER, selon le cas.  
  
## <a name="returns"></a>Valeur renvoyée  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR ou SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnostics  
 Lorsque **SQLSetStmtAttr** retourne SQL_ERROR ou SQL_SUCCESS_WITH_INFO, une valeur SQLSTATE associée peut être obtenu en appelant **SQLGetDiagRec** avec un *HandleType* de SQL_HANDLE_STMT et un *gérer* de *au paramètre StatementHandle*. Le tableau suivant répertorie les valeurs SQLSTATE généralement retournées par **SQLSetStmtAttr** et explique chacune d’elles dans le contexte de cette fonction ; la notation « (DM) » précède les descriptions de SQLSTATE retournée par le Gestionnaire de pilotes. Le code de retour associé à chaque valeur SQLSTATE est SQL_ERROR, sauf indication contraire.  
  
|SQLSTATE|Erreur| Description|  
|--------------|-----------|-----------------|  
|01000|Avertissement général|Message d’information de spécifiques au pilote. (La fonction retourne SQL_SUCCESS_WITH_INFO).|  
|01S02|Valeur de l’option modifiée|Le pilote ne prenait pas en charge la valeur spécifiée dans *ValuePtr*, ou la valeur spécifiée dans *ValuePtr* était non valide en raison de conditions de travail de mise en œuvre, le pilote remplacé une valeur similaire. (**SQLGetStmtAttr** peut être appelée pour déterminer la valeur substituée temporairement.) La valeur de remplacement n’est valide pour le *au paramètre StatementHandle* jusqu'à ce que le curseur est fermé, à quel point l’attribut d’instruction reprend sa valeur précédente. Les attributs d’instruction qui peuvent être modifiés sont :<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La fonction retourne SQL_SUCCESS_WITH_INFO).|  
|08S01|Échec de lien de communication|Échec de la liaison de communication entre le pilote et la source de données à laquelle le pilote a été connecté avant le traitement de la fonction a été exécutée.|  
|24000|État de curseur non valide|Le *attribut* a été SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR ou SQL_ATTR_USE_BOOKMARKS, et le curseur a été ouvert.|  
|HY000|Erreur générale|Une erreur s’est produite pour laquelle aucun code SQLSTATE spécifique est survenu et pour lequel aucune SQLSTATE spécifique à l’implémentation a été définie. Le message d’erreur retourné par **SQLGetDiagRec** dans les  *\*MessageText* tampon décrit l’erreur et sa cause.|  
|HY001|Erreur d’allocation de mémoire|Le pilote n’a pas pu allouer la mémoire requise pour prendre en charge l’exécution ou à l’achèvement de la fonction.|  
|HY009|Utilisation non valide d’un pointeur null|Le *attribut* argument identifié un attribut d’instruction qui a un attribut de chaîne requis et le *ValuePtr* argument était un pointeur null.|  
|HY010|Erreur de séquence de fonction|(DM), une fonction de façon asynchrone en cours d’exécution a été appelée pour le handle de connexion qui est associé à la *au paramètre StatementHandle*. Cette fonction asynchrone toujours en cours d’exécution lorsque le **SQLSetStmtAttr** fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, ou **SQLMoreResults** a été appelé pour le *au paramètre StatementHandle* et a retourné SQL_PARAM_DATA_AVAILABLE. Cette fonction a été appelée avant la récupération des données pour tous les paramètres transmis en continu.<br /><br /> (DM), une fonction de façon asynchrone en cours d’exécution a été appelée pour le *au paramètre StatementHandle* et toujours en cours d’exécution lorsque cette fonction a été appelée.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, ou **SQLSetPos** a été appelé pour le *au paramètre StatementHandle* et retourné SQL_NEED_DATA. Cette fonction a été appelée avant l’envoi de données pour tous les paramètres de data-at-execution ou les colonnes.|  
|HY011|Attribut ne peut pas être défini maintenant|Le *attribut* était SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR ou SQL_ ATTR_USE_BOOKMARKS, et l’instruction a été préparée.|  
|HY013|Erreur de gestion de mémoire|L’appel de fonction n’a pas pu être traité, car les objets sous-jacents de la mémoire ne sont pas accessible, éventuellement en raison d’une mémoire insuffisante.|  
|HY017|Utilisation non valide d’un handle de descripteur alloué automatiquement|(DM) le *attribut* argument a été SQL_ATTR_IMP_ROW_DESC ou SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) le *attribut* argument a été SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC et la valeur dans *ValuePtr* était un handle de descripteur alloué implicitement autre que le handle initialement alloué pour le ARD ou APD.|  
|HY024|Valeur d’attribut non valide|Étant donné le spécifié *attribut* , une valeur non valide a été spécifiée dans *ValuePtr*. (Le Gestionnaire de pilotes retourne ce SQLSTATE uniquement pour les connexions et les attributs de l’instruction qui acceptent un ensemble discret de valeurs, telles que SQL_ATTR_ACCESS_MODE ou SQL_ ATTR_ASYNC_ENABLE. Pour toutes les autres connexions et les attributs d’instruction, le pilote doit vérifier la valeur spécifiée dans *ValuePtr*.)<br /><br /> Le *attribut* argument a été SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC, et *ValuePtr* a été un handle de descripteur alloué de manière explicite qui n’est pas sur la même connexion que la *au paramètre StatementHandle* argument.|  
|HY090|Longueur de chaîne ou une mémoire tampon non valide|(DM)  *\*ValuePtr* est une chaîne de caractères et le *StringLength* argument était inférieure à 0 mais pas SQL_NTS.|  
|HY092|Identificateur d’attribut/option non valide|(DM) la valeur spécifiée pour l’argument *attribut* n’était pas valide pour la version d’ODBC pris en charge par le pilote.<br /><br /> (DM) la valeur spécifiée pour l’argument *attribut* a un attribut en lecture seule.|  
|HY117|Connexion est interrompue en raison de l’état de transaction inconnu. Déconnecter uniquement et les fonctions en lecture seule sont autorisées.|(DM) pour plus d’informations sur l’état suspendu, consultez [fonction SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Fonctionnalité facultative non implémentée|La valeur spécifiée pour l’argument *attribut* a un attribut d’instruction ODBC valide pour la version d’ODBC pris en charge par le pilote, mais n’était pas prise en charge par le pilote.<br /><br /> Le *attribut* argument a été SQL_ATTR_ASYNC_ENABLE et un appel à **SQLGetInfo** avec un *InfoType* SQL_ASYNC_MODE retourne SQL_AM_CONNECTION.<br /><br /> Le *attribut* argument SQL_ATTR_ENABLE_AUTO_IPD, et la valeur de l’attribut de connexion SQL_ATTR_AUTO_IPD était SQL_FALSE.|  
|HYT01|Délai de connexion a expiré.|Le délai d’expiration de connexion a expiré avant que la source de données a répondu à la demande. Le délai d’expiration de connexion est défini par le **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Pilote ne prend pas en charge cette fonction|(DM) le pilote associé à la *au paramètre StatementHandle* ne prend pas en charge la fonction.|  
|S1118|Pilote ne prend pas en charge la notification asynchrone|Si l’appel **SQLSetStmtAttr** définir SQL_ATTR_ASYNC_STMT_EVENT ; notification asynchrone n’est pas pris en charge par le pilote.|  
  
## <a name="comments"></a>Commentaires  
 Les attributs d’instruction pour une instruction restent en vigueur jusqu'à ce qu’ils sont modifiés par un autre appel à **SQLSetStmtAttr** ou jusqu'à ce que l’instruction est supprimée en appelant **SQLFreeHandle**. Appel de **SQLFreeStmt** avec le SQL_CLOSE, SQL_UNBIND ou SQL_RESET_PARAMS option ne réinitialise pas les attributs d’instruction.  
  
 Certains attributs de l’instruction de prendre en charge la substitution d’une valeur similaire si la source de données ne prend pas en charge la valeur spécifiée dans *ValuePtr*. Dans ce cas, le pilote retourne 01 s 02 SQL_SUCCESS_WITH_INFO et SQLSTATE (Option la valeur modifiée). Par exemple, si *attribut* est SQL_ATTR_CONCURRENCY et *ValuePtr* est SQL_CONCUR_ROWVER, et si la source de données ne prend pas en charge cela, le pilote remplace SQL_CONCUR_VALUES retourne SQL_SUCCESS_WITH_INFO. Pour déterminer la valeur substituée, une application appelle **SQLGetStmtAttr**.  
  
 Le format des informations définies avec *ValuePtr* dépend spécifié *attribut*. **SQLSetStmtAttr** accepte les informations d’attribut dans un des deux formats : une chaîne de caractères ou une valeur entière. Le format de chaque est indiqué dans la description de l’attribut. Ce format s’applique aux informations retournées pour chaque attribut dans **SQLGetStmtAttr**. Désigné par des chaînes de caractères le *ValuePtr* argument de **SQLSetStmtAttr** avoir une longueur de *StringLength*.  
  
> [!NOTE]  
>  La possibilité de définir des attributs de l’instruction au niveau de la connexion en appelant **SQLSetConnectAttr** a été déconseillée dans ODBC 3 *.x*. ODBC 3 *.x* applications ne doivent jamais définir les attributs d’instruction au niveau de la connexion. ODBC 3 *.x* les attributs d’instruction ne peut pas être définies au niveau de la connexion, à l’exception des attributs SQL_ATTR_METADATA_ID et SQL_ATTR_ASYNC_ENABLE, qui sont des attributs de connexion et les attributs d’instruction et peut être définie au niveau de la connexion ou de niveau de l’instruction.  
  
> [!NOTE]  
>  ODBC 3 *.x* pilotes doivent prennent uniquement en charge cette fonctionnalité s’ils doivent collaborer avec ODBC 2 *.x* application qui définira ODBC 2 *.x* options d’instruction au niveau de la connexion. Pour plus d’informations, consultez « Paramètre instruction Options sur le niveau de connexion » sous [SQLSetConnectOption mappage](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) dans l’annexe g : pilote recommandations pour la compatibilité descendante.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Attributs qui définissent des champs du descripteur d’instruction  
 Plusieurs attributs d’instruction correspondent à un champ d’en-tête d’un descripteur. Définition de ces attributs réellement les résultats dans le paramètre des champs de descripteur. Définition des champs par un appel à **SQLSetStmtAttr** au lieu de **SQLSetDescField** a l’avantage qu’un handle de descripteur ne doit pas être obtenu pour l’appel de fonction.  
  
> [!CAUTION]  
>  Appel de **SQLSetStmtAttr** pour une seule instruction peut affecter les autres instructions. Cela se produit lorsque le APD ou ARD associé à l’instruction est explicitement alloué est également associé avec d’autres instructions. Étant donné que **SQLSetStmtAttr** modifie le APD ou ARD, les modifications s’appliquent à toutes les instructions à laquelle ce descripteur est associé. Si ce comportement n’est pas obligatoire, l’application doit dissocier ce descripteur à partir d’autres instructions (en appelant **SQLSetStmtAttr** pour définir le champ SQL_ATTR_APP_ROW_DESC ou SQL_ATTR_APP_PARAM_DESC à un handle de descripteur différents) avant d’appeler **SQLSetStmtAttr** à nouveau.  
  
 Lorsqu’un champ de descripteur est défini à la suite de l’attribut d’instruction correspondant qui est définie, le champ est défini uniquement pour les descripteurs applicables qui sont actuellement associés à l’instruction identifiée par le *au paramètre StatementHandle* argument et le paramètre d’attribut n’affecte pas tous les descripteurs qui peuvent être associés à cette instruction dans le futur. Lorsqu’un champ de descripteur qui est également un attribut d’instruction est défini par un appel à **SQLSetDescField**, l’attribut d’instruction correspondant est défini. Si un descripteur explicitement alloué est dissocié d’une instruction, un attribut d’instruction qui correspond à un champ d’en-tête reviendra à la valeur du champ de descripteur alloué de manière implicite.  
  
 Lorsqu’une instruction est allouée (consultez [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), quatre poignées de descripteur sont automatiquement allouées et associées à l’instruction. Handles de descripteur alloué de manière explicite peuvent être associés à l’instruction en appelant **SQLAllocHandle** avec un *fHandleType* de SQL_HANDLE_DESC pour allouer un handle de descripteur et en appelant **SQLSetStmtAttr** à associer le handle du descripteur de l’instruction.  
  
 Les attributs d’instruction dans le tableau suivant correspondent aux champs d’en-tête de descripteur.  
  
|Attribut d’instruction|Champ d’en-tête|DESC.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Attributs d'instruction  
 Les attributs actuellement définis et la version d’ODBC dans lequel elles ont été ajoutées sont affichés dans le tableau suivant ; Il est probable que des attributs seront définis par les pilotes pour tirer parti de différentes sources de données. Une plage d’attributs est réservée par ODBC ; les développeurs de pilote doivent réserver valeurs pour leur propre usage spécifiques au pilote à partir d’Open Group. Pour plus d’informations, consultez [les Types de données spécifiques au pilote, Types de descripteur, Types d’informations, Types de diagnostics et attributs](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Attribut|*ValuePtr* contenu|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|Le handle pour le descripteur APD pour les appels suivants à **SQLExecute** et **SQLExecDirect** sur le descripteur d’instruction. La valeur initiale de cet attribut est le descripteur implicitement alloué lors de l’instruction a été initialement allouée. Si la valeur de cet attribut est définie à SQL_NULL_DESC ou le handle initialement allouée pour le descripteur, un handle APD explicitement alloué qui a été précédemment associé avec le descripteur d’instruction est dissocié de celle-ci et le descripteur d’instruction rétablit le descripteur APD implicitement alloué.<br /><br /> Cet attribut ne peut pas être défini à un handle de descripteur qui a été implicitement alloué pour une autre instruction ou à un autre handle de descripteur qui a été implicitement défini sur la même instruction ; handles de descripteur alloué implicitement ne peut pas être associés à plusieurs instructions ou le handle de descripteur.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|Handle vers le ARD pour les extractions suivantes sur le handle d’instruction. La valeur initiale de cet attribut est le descripteur implicitement alloué lors de l’instruction a été initialement allouée. Si la valeur de cet attribut est définie à SQL_NULL_DESC ou le handle initialement allouée pour le descripteur, un handle ARD explicitement alloué qui a été précédemment associé avec le descripteur d’instruction est dissocié de celle-ci et le descripteur d’instruction rétablit le handle ARD implicitement alloué.<br /><br /> Cet attribut ne peut pas être défini à un handle de descripteur qui a été implicitement alloué pour une autre instruction ou à un autre handle de descripteur qui a été implicitement défini sur la même instruction ; handles de descripteur alloué implicitement ne peut pas être associés à plusieurs instructions ou le handle de descripteur.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC VERSION 1.0)|Une valeur SQLULEN qui indique si une fonction appelée avec l’instruction spécifiée est exécutée de façon asynchrone :<br /><br /> SQL_ASYNC_ENABLE_OFF = prise en charge de l’exécution asynchrone au niveau instruction désactiver (la valeur par défaut).<br /><br /> SQL_ASYNC_ENABLE_ON = prise en charge du niveau de l’exécution asynchrone activer instruction.<br /><br /> Pour plus d’informations, consultez [exécution asynchrone (méthode d’interrogation)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Pour les pilotes avec prise en charge de l’exécution asynchrone au niveau instruction, l’attribut d’instruction SQL_ATTR_ASYNC_ENABLE est en lecture seule. Sa valeur est identique à la valeur de l’attribut de niveau connexion portant le même nom au moment où que le descripteur d’instruction a été alloué.<br /><br /> Appel de **SQLSetStmtAttr** pour définir SQL_ATTR_ASYNC_ENABLE lorsque le SQL_ASYNC_MODE *InfoType* retourne SQL_AM_CONNECTION retourne SQLSTATE HYC00 (fonctionnalité facultative non implémentée). Pour plus d’informations, consultez [fonction SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) pour plus d’informations.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Valeur SQLPOINTER qui est un handle d’événement.<br /><br /> Notification de fin de fonctions asynchrones est activée en appelant **SQLSetStmtAttr** pour définir le **SQL_ATTR_ASYNC_STMT_EVENT** d’attribut et spécifiez le handle d’événement.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER vers la fonction de rappel asynchrone.<br /><br /> Seul le Gestionnaire de pilotes peut appeler d’un pilote **SQLSetStmtAttr** fonction avec cet attribut.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER vers la structure de contexte<br /><br /> Seul le Gestionnaire de pilotes peut appeler d’un pilote **SQLSetStmtAttr** fonction avec cet attribut.|  
|SQL_ATTR_CONCURRENCY (ODBC VERSION 2.0)|Une valeur SQLULEN qui spécifie l’accès concurrentiel au curseur :<br /><br /> SQL_CONCUR_READ_ONLY = curseur est en lecture seule. Aucune mise à jour n’est autorisées.<br /><br /> SQL_CONCUR_LOCK = curseur utilise le niveau de verrouillage pour vous assurer que la ligne peut être mis à jour le plus bas.<br /><br /> SQL_CONCUR_ROWVER = curseur le contrôle d’accès concurrentiel optimiste utilise en comparant les versions de ligne telles que SQLBase ROWID ou Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = curseur le contrôle d’accès concurrentiel optimiste utilise en comparant les valeurs.<br /><br /> La valeur par défaut pour SQL_ATTR_CONCURRENCY est SQL_CONCUR_READ_ONLY.<br /><br /> Cet attribut ne peut pas être spécifié pour un curseur ouvert. Pour plus d’informations, consultez [les Types d’accès concurrentiel](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si le SQL_ATTR_CURSOR_TYPE *attribut* est remplacé par un type que ne prend pas en charge la valeur actuelle de la valeur de SQL_ATTR_CONCURRENCY SQL_ATTR_CONCURRENCY passera au moment de l’exécution et un avertissement émis quand **SQLExecDirect** ou **SQLPrepare** est appelée.<br /><br /> Si le pilote prend en charge la **sélectionner pour la mise à jour** instruction et une telle instruction est exécutée alors que la valeur de SQL_ATTR_CONCURRENCY est la valeur SQL_CONCUR_READ_ONLY, une erreur est renvoyée. Si la valeur de SQL_ATTR_CONCURRENCY est modifiée à une valeur que le pilote prend en charge pour une valeur de SQL_ATTR_CURSOR_TYPE, mais pas pour la valeur actuelle de SQL_ATTR_CURSOR_TYPE, la valeur de SQL_ATTR_CURSOR_TYPE passera au moment de l’exécution et SQLSTATE 01 s 02 (valeur de l’Option modifié) est émis lorsque **SQLExecDirect** ou **SQLPrepare** est appelée.<br /><br /> Si l’accès concurrentiel spécifié n’est pas pris en charge par la source de données, le pilote remplace une concurrence différentes et retourne SQLSTATE 01 s 02 (Option la valeur modifiée). Pour SQL_CONCUR_VALUES, le pilote remplace SQL_CONCUR_ROWVER et vice versa. Pour SQL_CONCUR_LOCK, le pilote remplace, dans l’ordre, SQL_CONCUR_ROWVER ou SQL_CONCUR_VALUES. La validité de la valeur substituée n’est pas vérifiée jusqu’au moment de l’exécution.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CONCURRENCY et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le niveau de prise en charge nécessaires à l’application. Si cet attribut a une incidence sur les appels suivants à **SQLExecDirect** et **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = à défilement les curseurs ne sont pas requis sur le handle d’instruction. Si l’application appelle **SQLFetchScroll** sur ce handle, la seule valeur valide de *FetchOrientation* est SQL_FETCH_NEXT. Il s'agit du paramètre par défaut.<br /><br /> SQL_SCROLLABLE = à défilement curseurs sont requises sur le handle d’instruction. Lors de l’appel **SQLFetchScroll**, l’application peut spécifier les valeurs valides de *FetchOrientation*, obtenez le positionnement du curseur dans les modes autres que le mode séquentiel.<br /><br /> Pour plus d’informations sur les curseurs de défilement, consultez [curseurs permettant le défilement](../../../odbc/reference/develop-app/scrollable-cursors.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SCROLLABLE et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un SQLULEN qui spécifie si les curseurs sur le handle d’instruction rendre visibles les modifications apportées à un résultat de la valeur par un autre curseur. Si cet attribut a une incidence sur les appels suivants à **SQLExecDirect** et **SQLExecute**. Une application peut lire la valeur de cet attribut pour obtenir son état initial ou son état comme étant plus récemment définie par l’application.<br /><br /> SQL_UNSPECIFIED = il n’est pas spécifié le type de curseur et indique si les curseurs sur le handle d’instruction rendre visibles les modifications apportées à un jeu de résultats par un autre curseur. Curseurs sur le handle d’instruction peuvent rendre visible à aucun, tout ou partie de ces modifications. Il s'agit du paramètre par défaut.<br /><br /> SQL_INSENSITIVE = tous les curseurs de l’émission de handle d’instruction le jeu de résultats sans refléter toutes les modifications apportées à ce dernier par n’importe quel autre curseur. Les curseurs insensibles sont en lecture seule. Cela correspond à un curseur statique, ce qui a une concurrence est en lecture seule.<br /><br /> SQL_SENSITIVE = tous les curseurs de l’instruction handle afficher toutes les modifications apportées à un résultat définies par un autre curseur.<br /><br /> Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_SENSITIVITY et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC VERSION 2.0)|Une valeur SQLULEN qui spécifie le type de curseur :<br /><br /> SQL_CURSOR_FORWARD_ONLY = le curseur uniquement fait défiler vers l’avant.<br /><br /> SQL_CURSOR_STATIC = les données dans le résultat de l’ensemble est statique.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = le pilote enregistre et utilise les clés pour le nombre de lignes spécifié dans l’attribut d’instruction SQL_ATTR_KEYSET_SIZE.<br /><br /> Type SQL_CURSOR_DYNAMIC = le pilote enregistre et utilise uniquement les clés pour les lignes de l’ensemble de lignes.<br /><br /> La valeur par défaut est SQL_CURSOR_FORWARD_ONLY. Cet attribut ne peut pas être spécifié après que l’instruction SQL a été préparée.<br /><br /> Si le type de curseur spécifié n’est pas pris en charge par la source de données, le pilote remplace un autre type de curseur et retourne SQLSTATE 01 s 02 (Option la valeur modifiée). Pour un curseur dynamique ou mixte, le pilote remplace, dans l’ordre, un curseur piloté par jeu de clés ou statique. Pour un curseur keyset, le pilote remplace un curseur statique.<br /><br /> Pour plus d’informations sur les types de curseur de défilement, consultez [des Types de curseurs permettant le défilement](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Pour plus d’informations sur la relation entre SQL_ATTR_CURSOR_TYPE et les autres attributs de curseur, consultez [caractéristiques du curseur et le Type de curseur](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Une valeur SQLULEN qui spécifie si le remplissage automatique de l’IPD est effectué :<br /><br /> SQL_TRUE = Active le remplissage automatique de l’IPD après un appel à **SQLPrepare**. SQL_FALSE = désactive le remplissage automatique de l’IPD après un appel à **SQLPrepare**. (Une application peut toujours obtenir les informations de champ IPD en appelant **SQLDescribeParam**, si pris en charge.) La valeur par défaut de l’attribut d’instruction SQL_ATTR_ENABLE_AUTO_IPD est SQL_FALSE. Pour plus d’informations, consultez [le remplissage automatique de l’IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* qui pointe vers une valeur binaire de signet. Lorsque **SQLFetchScroll** est appelée avec *fFetchOrientation* égal à SQL_FETCH_BOOKMARK, le pilote récupère la valeur du signet à partir de ce champ. Par défaut, ce champ est un pointeur null. Pour plus d’informations, consultez [le défilement par signet](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> La valeur indiquée par ce champ n’est pas utilisée par un signet pour supprimer, mettre à jour par un signet ou extraire par les opérations de signet dans **SQLBulkOperations**, qui utilisent des signets mis en cache des tampons de l’ensemble de lignes.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|Le handle à l’IPD. La valeur de cet attribut est le descripteur alloué lors de l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas définie par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|Descripteur de l’IRD. La valeur de cet attribut est le descripteur alloué lors de l’instruction a été initialement allouée. L’application ne peut pas définir cet attribut.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas définie par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC VERSION 2.0)|SQLULEN qui spécifie le nombre de lignes dans le jeu de clés pour un curseur keyset. Si la taille du jeu de clés est 0 (la valeur par défaut), le curseur est entièrement commandé par keyset. Si la taille du jeu de clés est supérieure à 0, le curseur est mixte (keyset dans le jeu de clés et dynamiques en dehors du jeu de clés). La taille du jeu de clés par défaut est 0. Pour plus d’informations sur les curseurs, consultez [curseurs contrôlés par clés](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si la taille spécifiée dépasse la taille maximale de jeu de clés, le pilote remplace la taille spécifiée et retourne SQLSTATE 01 s 02 (Option la valeur modifiée).<br /><br /> **SQLFetch** ou **SQLFetchScroll** renvoie une erreur si la taille du jeu de clés est supérieur à 0 et inférieur à la taille de l’ensemble de lignes.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Une valeur SQLULEN qui spécifie la quantité maximale de données renvoyées par le pilote à partir d’une colonne caractère ou binaire. Si *ValuePtr* est inférieure à la longueur des données disponibles, **SQLFetch** ou **SQLGetData** tronque les données et retourne SQL_SUCCESS. Si *ValuePtr* est 0 (la valeur par défaut), le pilote tente de renvoyer toutes les données disponibles.<br /><br /> Si la longueur spécifiée est inférieure à la quantité minimale de données que la source de données peut renvoyer ou supérieur à la quantité maximale de données que la source de données peut renvoyer, substituts pilote valeur et retourne SQLSTATE 01 s 02 (Option la valeur modifiée).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut prendront effet immédiatement, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (Option la valeur modifiée) et réinitialiser l’attribut à sa valeur d’origine.<br /><br /> Cet attribut est destiné à réduire le trafic réseau et doit être pris en charge uniquement lorsque la source de données (par opposition au pilote) dans un pilote à plusieurs niveaux peut implémenter. Ce mécanisme ne doit pas être utilisé par les applications pour tronquer des données ; pour tronquer des données reçues, une application doit spécifier la longueur maximale de mémoire tampon dans le *BufferLength* argument dans **SQLBindCol** ou **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC VERSION 1.0)|Une valeur SQLULEN correspondant au nombre maximal de lignes à retourner à l’application pour un **sélectionnez** instruction. Si \* *ValuePtr* est égal à 0 (la valeur par défaut), le pilote retourne toutes les lignes.<br /><br /> Cet attribut est destiné à réduire le trafic réseau. Point de vue conceptuel, elle est appliquée lorsque le jeu de résultats est créé et limite le jeu de résultats pour la première *ValuePtr* lignes. Si le nombre de lignes du jeu de résultats est supérieur à *ValuePtr*, le jeu de résultats est tronqué.<br /><br /> SQL_ATTR_MAX_ROWS s’applique à tous les jeux de résultats sur le *instruction*, y compris ceux retournés par les fonctions de catalogue. SQL_ATTR_MAX_ROWS établit un maximum pour la valeur du nombre de lignes du curseur.<br /><br /> Un pilote ne doit pas émuler comportement SQL_ATTR_MAX_ROWS pour **SQLFetch** ou **SQLFetchScroll** (si les limitations de taille de jeu de résultats ne peut pas être implémentées à la source de données) si elle ne peut pas garantir que SQL_ATTR_MAX_ROWS sera implémentée correctement.<br /><br /> Elle est définie par le pilote que SQL_ATTR_MAX_ROWS s’appliquent aux instructions autres que les instructions SELECT (par exemple, les fonctions de catalogue).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut prendront effet immédiatement, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (Option la valeur modifiée) et réinitialiser l’attribut à sa valeur d’origine.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Une valeur SQLULEN qui détermine la façon dont les arguments de chaîne de fonctions de catalogue sont traités.<br /><br /> Si SQL_TRUE, l’argument de chaîne de fonctions de catalogue sont traités comme des identificateurs. La casse n’est pas significative. Pour les chaînes non délimités, le pilote supprime les espaces de fin et la chaîne est pliée en majuscules. Pour les chaînes délimitées, le pilote supprime les espaces de début ou de fin et accepte tout ce qui est situé entre les délimiteurs littéralement. Si un de ces arguments est défini à un pointeur null, la fonction retourne SQL_ERROR et SQLSTATE HY009 (utilisation non valide d’un pointeur null).<br /><br /> Si vous SQL_FALSE, les arguments de chaîne de fonctions de catalogue ne sont pas traités comme des identificateurs. La casse est importante. Ils peuvent contenir un modèle de recherche de chaîne ou non, en fonction de l’argument.<br /><br /> La valeur par défaut est SQL_FALSE.<br /><br /> Le *TableType* argument de **SQLTables**, qui accepte une liste de valeurs, n’est pas affectée par cet attribut.<br /><br /> SQL_ATTR_METADATA_ID peut également être définie sur le niveau de la connexion. (Il et SQL_ATTR_ASYNC_ENABLE sont les attributs de la seule instruction qui sont également des attributs de connexion).<br /><br /> Pour plus d’informations, consultez [Arguments dans les fonctions de catalogue](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC VERSION 1.0)|Une valeur SQLULEN qui indique si le pilote doit analyser les chaînes SQL pour les séquences d’échappement :<br /><br /> SQL_NOSCAN_OFF = les analyses de pilote chaînes SQL pour les séquences d’échappement (par défaut).<br /><br /> SQL_NOSCAN_ON = le pilote n’analyse pas les chaînes SQL pour les séquences d’échappement. Au lieu de cela, le pilote envoie l’instruction directement à la source de données.<br /><br /> Pour plus d’informations, consultez [les séquences d’échappement dans ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valeur pointe vers un décalage ajouté aux pointeurs pour modifier la liaison de paramètres dynamiques. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Il a la valeur NULL par défaut.<br /><br /> Le décalage de la liaison est toujours ajouté directement aux champs SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR. Si le décalage est remplacé par une autre valeur, la nouvelle valeur est toujours ajoutée directement à la valeur dans le champ de descripteur. Nouvel offset n’est pas ajouté à la valeur du champ ainsi que les décalages antérieures.<br /><br /> Pour plus d’informations, consultez [paramètre liaison Offsets](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_BIND_OFFSET_PTR champ dans l’en-tête APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Une valeur SQLULEN qui indique l’orientation de la liaison à utiliser pour les paramètres dynamiques.<br /><br /> Ce champ a pour valeur SQL_PARAM_BIND_BY_COLUMN (la valeur par défaut) pour sélectionner la liaison.<br /><br /> Pour sélectionner la liaison, ce champ est défini à la longueur de la structure ou une instance d’une mémoire tampon qui sera liée à un ensemble de paramètres dynamiques. Cette longueur doit inclure un espace pour tous les paramètres liés et tout remplissage de la structure ou de la mémoire tampon pour vous assurer que lorsque l’adresse d’un paramètre dépendant est incrémenté à la longueur spécifiée, le résultat pointera vers le début de la même paramètre dans l’ensemble suivant de paramètres. Lorsque vous utilisez la *sizeof* opérateur en C ANSI, ce comportement est garanti.<br /><br /> Pour plus d’informations, consultez [liaison de tableaux de paramètres](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ BIND_TYPE champ dans l’en-tête APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de valeurs SQLUSMALLINT utilisée pour ignorer un paramètre pendant l’exécution d’une instruction SQL. Chaque valeur est définie à SQL_PARAM_PROCEED (pour le paramètre doit être exécuté) ou SQL_PARAM_IGNORE (pour le paramètre est ignoré).<br /><br /> Un ensemble de paramètres peut être ignoré lors du traitement en affectant la valeur d’état dans le tableau vers lequel pointé SQL_DESC_ARRAY_STATUS_PTR dans le descripteur APD à SQL_PARAM_IGNORE. Un ensemble de paramètres est traité si son état a la valeur à SQL_PARAM_PROCEED ou si aucun élément du tableau n’est définis.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas paramètre valeurs d’état. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée la prochaine fois que **SQLExecDirect** ou **SQLExecute** est appelée.<br /><br /> Cet attribut est ignoré lorsqu’il n’existe aucun paramètre lié.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ARRAY_STATUS_PTR champ dans l’en-tête APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de SQLUSMALLINT valeurs contenant des informations de statut pour chaque ligne de valeurs de paramètres après un appel à **SQLExecute** ou **SQLExecDirect**. Ce champ est obligatoire uniquement si PARAMSET_SIZE est supérieur à 1.<br /><br /> Les valeurs d’état peuvent contenir les valeurs suivantes :<br /><br /> SQL_PARAM_SUCCESS : L’instruction SQL a été correctement exécutée pour ce jeu de paramètres.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO : L’instruction SQL a été exécutée avec succès pour ce jeu de paramètres ; Toutefois, les informations d’avertissement sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_ERROR : Comportait une erreur lors du traitement de cet ensemble de paramètres. Informations d’erreur supplémentaires sont disponibles dans la structure de données de diagnostic.<br /><br /> SQL_PARAM_UNUSED : Ce jeu de paramètres a été inutilisé, probablement dû au fait que certains jeu de paramètres précédente a provoqué une erreur qui a annulé le traitement davantage ou car SQL_PARAM_IGNORE a été défini pour ce jeu de paramètres dans le tableau spécifié par le SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE : Le pilote traite les tableaux de paramètres comme une unité monolithique et donc ne génère pas de ce niveau d’informations d’erreur.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas paramètre valeurs d’état. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée la prochaine fois que **SQLExecute** ou **SQLExecDirect** est appelée. Notez que la définition de cet attribut peut affecter le comportement du paramètre de sortie implémenté par le pilote.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ARRAY_STATUS_PTR champ dans l’en-tête IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* champs d’enregistrements qui pointe vers une mémoire tampon dans lequel retourner le nombre de jeux de paramètres qui ont été traitées, y compris les jeux de l’erreur. Aucun nombre n’est retourné s’il s’agit d’un pointeur null.<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ROWS_PROCESSED_PTR champ dans l’en-tête IPD.<br /><br /> Si l’appel à **SQLExecDirect** ou **SQLExecute** que renseigne la mémoire tampon pointée par cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le nombre de valeurs pour chaque paramètre. Si SQL_ATTR_PARAMSET_SIZE est supérieur à 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR du point APD aux tableaux. La cardinalité de chaque tableau est égale à la valeur de ce champ.<br /><br /> Cet attribut est ignoré lorsqu’il n’existe aucun paramètre lié.<br /><br /> Pour plus d’informations, consultez [à l’aide des tableaux de paramètres](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ARRAY_SIZE champ dans l’en-tête APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC VERSION 1.0)|Une valeur SQLULEN correspondant au nombre de secondes d’attente d’une instruction SQL à exécuter avant de retourner à l’application. Si *ValuePtr* est égal à 0 (valeur par défaut), il n’existe aucun délai d’expiration.<br /><br /> Si le délai d’attente spécifié dépasse le délai d’attente maximal dans la source de données ou n’est plus petit que le délai d’attente minimum, **SQLSetStmtAttr** substitue cette valeur et retourne SQLSTATE 01 s 02 (Option la valeur modifiée).<br /><br /> Notez que l’application ne doive pas appeler **SQLCloseCursor** à réutiliser l’instruction si un **sélectionnez** instruction a expiré.<br /><br /> Le délai de requête de cet attribut d’instruction est valide dans les modes synchrones et asynchrones.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC VERSION 2.0)|Une valeur SQLULEN :<br /><br /> SQL_RD_ON = **SQLFetchScroll** et, dans ODBC 3 *.x*, **SQLFetch** récupérer des données après qu’il place le curseur à l’emplacement spécifié. Il s'agit du paramètre par défaut.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** et, dans ODBC 3 *.x*, **SQLFetch** ne récupèrent pas les données une fois qu’il place le curseur.<br /><br /> En affectant à SQL_RETRIEVE_DATA SQL_RD_OFF, une application peut vérifier qu’une ligne existe ou récupérer un signet pour la ligne sans subir la charge de l’extraction de lignes. Pour plus d’informations, consultez [défilement et extraction des lignes](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> La valeur de cet attribut peut être définie sur un curseur ouvert ; Toutefois, le paramètre peut prendront effet immédiatement, dans ce cas, le pilote retournera SQLSTATE 01 s 02 (Option la valeur modifiée) et réinitialiser l’attribut à sa valeur d’origine.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Une valeur SQLULEN qui spécifie le nombre de lignes renvoyées par chaque appel à **SQLFetch** ou **SQLFetchScroll**. Il est également le nombre de lignes dans un tableau de signet utilisée dans une opération de signet en bloc dans **SQLBulkOperations**. La valeur par défaut est 1.<br /><br /> Si la taille de l’ensemble de lignes spécifié dépasse la taille maximale prise en charge par la source de données, le pilote remplace cette valeur et retourne SQLSTATE 01 s 02 (Option la valeur modifiée).<br /><br /> Pour plus d’informations, consultez [taille de l’ensemble de lignes](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ARRAY_SIZE champ dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valeur pointe vers un décalage ajouté aux pointeurs pour modifier la liaison de données de la colonne. Si ce champ est non null, le pilote déréférence le pointeur, ajoute la valeur déréférencée à chacun des champs différés dans l’enregistrement de descripteur (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR et SQL_DESC_OCTET_LENGTH_PTR) et utilise les nouvelles valeurs de pointeur lors de la liaison. Il a la valeur NULL par défaut.<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_BIND_OFFSET_PTR champ dans l’en-tête ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Une valeur SQLULEN qui définit l’orientation de la liaison à utiliser lorsque **SQLFetch** ou **SQLFetchScroll** est appelée sur l’instruction associée. La liaison est sélectionnée en définissant la valeur sur SQL_BIND_BY_COLUMN. Liaison selon les lignes est activée en définissant la valeur à la longueur d’une structure ou une instance d’une mémoire tampon dans laquelle les colonnes de résultats seront liés.<br /><br /> Si une longueur est spécifiée, elle doit inclure l’espace pour toutes les colonnes dépendantes et tout remplissage de la structure ou de la mémoire tampon pour vous assurer que lorsque l’adresse d’une colonne dépendante est incrémentée de la longueur spécifiée, le résultat pointera vers le début de la même colonne dans la ligne suivante. Lorsque vous utilisez la **sizeof** (opérateur) avec les structures ou unions en C ANSI, ce comportement est garanti.<br /><br /> La liaison est l’orientation de la liaison par défaut pour **SQLFetch** et **SQLFetchScroll**.<br /><br /> Pour plus d’informations, consultez [de liaison des colonnes pour une utilisation avec les curseurs de bloc](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_BIND_TYPE champ dans l’en-tête ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC VERSION 2.0)|Une valeur SQLULEN qui est le numéro de la ligne actuelle dans l’ensemble de résultats est définie. Si le numéro de la ligne actuelle ne peut pas être déterminé ou il n’existe pas de ligne actuelle, le pilote retourne 0.<br /><br /> Cet attribut peut être récupéré par un appel à **SQLGetStmtAttr** mais pas définie par un appel à **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de valeurs SQLUSMALLINT utilisée pour ignorer une ligne pendant une opération en bloc à l’aide **SQLSetPos**. Chaque valeur est définie à SQL_ROW_PROCEED (pour la ligne à inclure dans l’opération en bloc) ou SQL_ROW_IGNORE (pour la ligne à exclure de l’opération en bloc). (Les lignes ne peuvent pas être ignorées à l’aide de ce tableau lors des appels à **SQLBulkOperations**.)<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas les valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée la prochaine fois que **SQLSetPos** est appelée.<br /><br /> Pour plus d’informations, consultez [mise à jour des lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) et [suppression de lignes dans l’ensemble de lignes avec SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Si cet attribut d’instruction définit le champ SQL_DESC_ARRAY_STATUS_PTR le ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valeur qui pointe vers un tableau de SQLUSMALLINT valeurs contenant des valeurs état ligne après un appel à **SQLFetch** ou **SQLFetchScroll**. Le tableau a autant d’éléments qu’il existe des lignes dans l’ensemble de lignes.<br /><br /> Cet attribut d’instruction peut être défini à un pointeur null, dans lequel le cas, le pilote ne retourne pas les valeurs d’état de ligne. Cet attribut peut être défini à tout moment, mais la nouvelle valeur n’est pas utilisée la prochaine fois que **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, ou **SQLSetPos** est appelée.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et l’état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ARRAY_STATUS_PTR champ dans l’en-tête IRD.<br /><br /> Cet attribut est mappé à une API ODBC 2 *.x* pilote à la *rgbRowStatus* tableau dans un appel à **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* valeur pointe vers une mémoire tampon dans lequel retourner le nombre de lignes extraites après un appel à **SQLFetch** ou **SQLFetchScroll**; le nombre de lignes affectées par une opération en bloc effectuée par un appel à **SQLSetPos** avec un *opération* argument de SQL_REFRESH ; ou le nombre de lignes affectées par une opération en bloc effectuée par **SQLBulkOperations**. Ce nombre comprend les lignes d’erreur.<br /><br /> Pour plus d’informations, consultez [nombre de lignes extraites et l’état](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Si cet attribut d’instruction définit la SQL_DESC_ROWS_PROCESSED_PTR champ dans l’en-tête IRD.<br /><br /> Si l’appel à **SQLFetch** ou **SQLFetchScroll** que renseigne la mémoire tampon pointée par cet attribut ne retourne pas SQL_SUCCESS ou SQL_SUCCESS_WITH_INFO, le contenu de la mémoire tampon n’est pas défini.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC VERSION 2.0)|Une valeur SQLULEN qui spécifie si les pilotes qui simulent positionnés mettre à jour et supprimer les instructions garantit que ces instructions n'affectent qu’une seule ligne.<br /><br /> Pour simuler la mise à jour positionnée et supprimer des instructions, la plupart des pilotes de construire une recherche **mettre à jour** ou **supprimer** instruction contenant un **où** clause qui spécifie la valeur de chaque colonne dans la ligne actuelle. À moins que ces colonnes composent une clé unique, une telle déclaration peut affecter plusieurs lignes.<br /><br /> Pour garantir que ces instructions n'affectent qu’une seule ligne, le pilote détermine les colonnes d’une clé unique et ajoute ces colonnes pour le jeu de résultats. Si une application garantit que les colonnes du jeu de résultats constituent une clé unique, le pilote n’est pas obligé de le faire. Cela peut réduire les temps d’exécution.<br /><br /> SQL_SC_NON_UNIQUE = le pilote ne garantit pas simulée positionné mise à jour ou d’instructions delete affecte qu’une seule ligne ; Il est responsable de l’application à le faire. Si une instruction concerne plusieurs lignes, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_TRY_UNIQUE = les tentatives de pilote afin de garantir que simulée positionné mise à jour ou supprimer des instructions affectent qu’une seule ligne. Le pilote exécute toujours ces instructions, même si elles peuvent affecter plusieurs lignes, par exemple quand il n’existe aucune clé unique. Si une instruction concerne plusieurs lignes, **SQLExecute**, **SQLExecDirect**, ou **SQLSetPos** retourne SQLSTATE 01001 (conflit d’opération de curseur).<br /><br /> SQL_SC_UNIQUE = les garanties de pilote qui simulée de mise à jour positionnée ou de supprimer les instructions affectent qu’une seule ligne. Si le pilote ne peut pas garantir cela pour une instruction donnée, **SQLExecDirect** ou **SQLPrepare** renvoie une erreur.<br /><br /> Si la source de données fournit SQL natif prend en charge pour la mise à jour positionnée et supprimer les instructions et le pilote ne simule pas les curseurs, SQL_SUCCESS est retournée lorsque SQL_SC_UNIQUE est demandé pour SQL_SIMULATE_CURSOR. SQL_SUCCESS_WITH_INFO est retourné si SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE est demandé. Si la source de données fournit le niveau SQL_SC_TRY_UNIQUE de prise en charge et le pilote n’est pas, la valeur SQL_SUCCESS est retournée pour SQL_SC_TRY_UNIQUE et SQL_SUCCESS_WITH_INFO est retourné pour SQL_SC_NON_UNIQUE.<br /><br /> Si le type de simulation du curseur spécifié n’est pas pris en charge par la source de données, le pilote remplace un type différent de simulation et retourne SQLSTATE 01 s 02 (Option la valeur modifiée). Pour SQL_SC_UNIQUE, le pilote remplace, dans l’ordre, SQL_SC_TRY_UNIQUE ou SQL_SC_NON_UNIQUE. Pour SQL_SC_TRY_UNIQUE, le pilote remplace SQL_SC_NON_UNIQUE.<br /><br /> La valeur par défaut est SQL_SC_UNIQUE.<br /><br /> Pour plus d’informations, consultez [simulant positionné instructions Update et Delete](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC VERSION 2.0)|Une valeur SQLULEN qui spécifie si une application doit utiliser des signets avec un curseur :<br /><br /> SQL_UB_OFF = Off (valeur par défaut)<br /><br /> SQL_UB_VARIABLE = une application pour utiliser les signets avec un curseur, et le pilote fournira des signets de longueur variable, si elles sont prises en charge. SQL_UB_FIXED est déconseillé dans ODBC 3 *.x*. ODBC 3 *.x* application doivent toujours utiliser des signets de longueur variable, même lorsque vous travaillez avec ODBC 2 *.x* pilotes (qui pris en charge uniquement sur 4 octets, de longueur fixe les signets). Il s’agit d’un signet de longueur fixe étant simplement un cas spécial d’un signet de longueur variable. Lorsque vous travaillez avec une API ODBC 2 *.x* pilote, le Gestionnaire de pilotes mappe SQL_UB_VARIABLE à SQL_UB_FIXED.<br /><br /> Pour utiliser des signets avec un curseur, l’application doit spécifier cet attribut avec la valeur SQL_UB_VARIABLE avant l’ouverture du curseur.<br /><br /> Pour plus d’informations, consultez [la récupération des signets](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1], ces fonctions peuvent être appelées de façon asynchrone uniquement si le descripteur est un descripteur d’implémentation, pas un descripteur de l’application.  
  
 Consultez [liaison selon les colonnes](../../../odbc/reference/develop-app/column-wise-binding.md) et [liaison selon les lignes](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Fonctions connexes  
  
|Pour obtenir des informations sur|Consultez|  
|---------------------------|---------|  
|L’annulation du traitement des instructions|[SQLCancel, fonction](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Retourner la valeur de l’attribut de connexion|[SQLGetConnectAttr, fonction](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Retourner le paramètre d’un attribut d’instruction|[SQLGetStmtAttr, fonction](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Définition d’un attribut de connexion|[SQLSetConnectAttr, fonction](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Définition d’un champ unique du descripteur|[SQLSetDescField, fonction](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Voir aussi  
 [Référence de l’API ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Fichiers d’en-tête ODBC](../../../odbc/reference/install/odbc-header-files.md)
